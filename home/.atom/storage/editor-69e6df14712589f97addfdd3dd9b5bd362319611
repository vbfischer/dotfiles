{"mode":"editor","version":1,"windowDimensions":{"x":239,"y":22,"width":1201,"height":878},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/bryce/Downloads/todo.txt_cli-2.10","buffers":[{"text":"#! /bin/bash\n\n# === HEAVY LIFTING ===\nshopt -s extglob extquote\n\n# NOTE:  Todo.sh requires the .todo/config configuration file to run.\n# Place the .todo/config file in your home directory or use the -d option for a custom location.\n\n[ -f VERSION-FILE ] && . VERSION-FILE || VERSION=\"2.10\"\nversion() {\n    cat <<-EndVersion\n\t\tTODO.TXT Command Line Interface v$VERSION\n\n\t\tFirst release: 5/11/2006\n\t\tOriginal conception by: Gina Trapani (http://ginatrapani.org)\n\t\tContributors: http://github.com/ginatrapani/todo.txt-cli/network\n\t\tLicense: GPL, http://www.gnu.org/copyleft/gpl.html\n\t\tMore information and mailing list at http://todotxt.com\n\t\tCode repository: http://github.com/ginatrapani/todo.txt-cli/tree/master\n\tEndVersion\n    exit 1\n}\n\n# Set script name and full path early.\nTODO_SH=$(basename \"$0\")\nTODO_FULL_SH=\"$0\"\nexport TODO_SH TODO_FULL_SH\n\noneline_usage=\"$TODO_SH [-fhpantvV] [-d todo_config] action [task_number] [task_description]\"\n\nusage()\n{\n    cat <<-EndUsage\n\t\tUsage: $oneline_usage\n\t\tTry '$TODO_SH -h' for more information.\n\tEndUsage\n    exit 1\n}\n\nshorthelp()\n{\n    cat <<-EndHelp\n\t\t  Usage: $oneline_usage\n\n\t\t  Actions:\n\t\t    add|a \"THING I NEED TO DO +project @context\"\n\t\t    addm \"THINGS I NEED TO DO\n\t\t          MORE THINGS I NEED TO DO\"\n\t\t    addto DEST \"TEXT TO ADD\"\n\t\t    append|app ITEM# \"TEXT TO APPEND\"\n\t\t    archive\n\t\t    command [ACTIONS]\n\t\t    deduplicate\n\t\t    del|rm ITEM# [TERM]\n\t\t    depri|dp ITEM#[, ITEM#, ITEM#, ...]\n\t\t    do ITEM#[, ITEM#, ITEM#, ...]\n\t\t    help [ACTION...]\n\t\t    list|ls [TERM...]\n\t\t    listall|lsa [TERM...]\n\t\t    listaddons\n\t\t    listcon|lsc [TERM...]\n\t\t    listfile|lf [SRC [TERM...]]\n\t\t    listpri|lsp [PRIORITIES] [TERM...]\n\t\t    listproj|lsprj [TERM...]\n\t\t    move|mv ITEM# DEST [SRC]\n\t\t    prepend|prep ITEM# \"TEXT TO PREPEND\"\n\t\t    pri|p ITEM# PRIORITY\n\t\t    replace ITEM# \"UPDATED TODO\"\n\t\t    report\n\t\t    shorthelp\n\n\t\t  Actions can be added and overridden using scripts in the actions\n\t\t  directory.\n\tEndHelp\n\n    # Only list the one-line usage from the add-on actions. This assumes that\n    # add-ons use the same usage indentation structure as todo.sh.\n    addonHelp | grep -e '^  Add-on Actions:' -e '^    [[:alpha:]]'\n\n    cat <<-EndHelpFooter\n\n\t\t  See \"help\" for more details.\n\tEndHelpFooter\n}\n\nhelp()\n{\n    cat <<-EndOptionsHelp\n\t\t  Usage: $oneline_usage\n\n\t\t  Options:\n\t\t    -@\n\t\t        Hide context names in list output.  Use twice to show context\n\t\t        names (default).\n\t\t    -+\n\t\t        Hide project names in list output.  Use twice to show project\n\t\t        names (default).\n\t\t    -c\n\t\t        Color mode\n\t\t    -d CONFIG_FILE\n\t\t        Use a configuration file other than the default ~/.todo/config\n\t\t    -f\n\t\t        Forces actions without confirmation or interactive input\n\t\t    -h\n\t\t        Display a short help message; same as action \"shorthelp\"\n\t\t    -p\n\t\t        Plain mode turns off colors\n\t\t    -P\n\t\t        Hide priority labels in list output.  Use twice to show\n\t\t        priority labels (default).\n\t\t    -a\n\t\t        Don't auto-archive tasks automatically on completion\n\t\t    -A\n\t\t        Auto-archive tasks automatically on completion\n\t\t    -n\n\t\t        Don't preserve line numbers; automatically remove blank lines\n\t\t        on task deletion\n\t\t    -N\n\t\t        Preserve line numbers\n\t\t    -t\n\t\t        Prepend the current date to a task automatically\n\t\t        when it's added.\n\t\t    -T\n\t\t        Do not prepend the current date to a task automatically\n\t\t        when it's added.\n\t\t    -v\n\t\t        Verbose mode turns on confirmation messages\n\t\t    -vv\n\t\t        Extra verbose mode prints some debugging information and\n\t\t        additional help text\n\t\t    -V\n\t\t        Displays version, license and credits\n\t\t    -x\n\t\t        Disables TODOTXT_FINAL_FILTER\n\n\n\tEndOptionsHelp\n\n    [ $TODOTXT_VERBOSE -gt 1 ] && cat <<-'EndVerboseHelp'\n\t\t  Environment variables:\n\t\t    TODOTXT_AUTO_ARCHIVE            is same as option -a (0)/-A (1)\n\t\t    TODOTXT_CFG_FILE=CONFIG_FILE    is same as option -d CONFIG_FILE\n\t\t    TODOTXT_FORCE=1                 is same as option -f\n\t\t    TODOTXT_PRESERVE_LINE_NUMBERS   is same as option -n (0)/-N (1)\n\t\t    TODOTXT_PLAIN                   is same as option -p (1)/-c (0)\n\t\t    TODOTXT_DATE_ON_ADD             is same as option -t (1)/-T (0)\n\t\t    TODOTXT_VERBOSE=1               is same as option -v\n\t\t    TODOTXT_DISABLE_FILTER=1        is same as option -x\n\t\t    TODOTXT_DEFAULT_ACTION=\"\"       run this when called with no arguments\n\t\t    TODOTXT_SORT_COMMAND=\"sort ...\" customize list output\n\t\t    TODOTXT_FINAL_FILTER=\"sed ...\"  customize list after color, P@+ hiding\n\t\t    TODOTXT_SOURCEVAR=\\$DONE_FILE   use another source for listcon, listproj\n\n\n\tEndVerboseHelp\n        actionsHelp\n        addonHelp\n}\n\nactionsHelp()\n{\n    cat <<-EndActionsHelp\n\t\t  Built-in Actions:\n\t\t    add \"THING I NEED TO DO +project @context\"\n\t\t    a \"THING I NEED TO DO +project @context\"\n\t\t      Adds THING I NEED TO DO to your todo.txt file on its own line.\n\t\t      Project and context notation optional.\n\t\t      Quotes optional.\n\n\t\t    addm \"FIRST THING I NEED TO DO +project1 @context\n\t\t    SECOND THING I NEED TO DO +project2 @context\"\n\t\t      Adds FIRST THING I NEED TO DO to your todo.txt on its own line and\n\t\t      Adds SECOND THING I NEED TO DO to you todo.txt on its own line.\n\t\t      Project and context notation optional.\n\n\t\t    addto DEST \"TEXT TO ADD\"\n\t\t      Adds a line of text to any file located in the todo.txt directory.\n\t\t      For example, addto inbox.txt \"decide about vacation\"\n\n\t\t    append ITEM# \"TEXT TO APPEND\"\n\t\t    app ITEM# \"TEXT TO APPEND\"\n\t\t      Adds TEXT TO APPEND to the end of the task on line ITEM#.\n\t\t      Quotes optional.\n\n\t\t    archive\n\t\t      Moves all done tasks from todo.txt to done.txt and removes blank lines.\n\n\t\t    command [ACTIONS]\n\t\t      Runs the remaining arguments using only todo.sh builtins.\n\t\t      Will not call any .todo.actions.d scripts.\n\n\t\t    deduplicate\n\t\t      Removes duplicate lines from todo.txt.\n\n\t\t    del ITEM# [TERM]\n\t\t    rm ITEM# [TERM]\n\t\t      Deletes the task on line ITEM# in todo.txt.\n\t\t      If TERM specified, deletes only TERM from the task.\n\n\t\t    depri ITEM#[, ITEM#, ITEM#, ...]\n\t\t    dp ITEM#[, ITEM#, ITEM#, ...]\n\t\t      Deprioritizes (removes the priority) from the task(s)\n\t\t      on line ITEM# in todo.txt.\n\n\t\t    do ITEM#[, ITEM#, ITEM#, ...]\n\t\t      Marks task(s) on line ITEM# as done in todo.txt.\n\n\t\t    help [ACTION...]\n\t\t      Display help about usage, options, built-in and add-on actions,\n\t\t      or just the usage help for the passed ACTION(s).\n\n\t\t    list [TERM...]\n\t\t    ls [TERM...]\n\t\t      Displays all tasks that contain TERM(s) sorted by priority with line\n\t\t      numbers.  Each task must match all TERM(s) (logical AND); to display\n\t\t      tasks that contain any TERM (logical OR), use\n\t\t      \"TERM1\\|TERM2\\|...\" (with quotes), or TERM1\\\\\\|TERM2 (unquoted).\n\t\t      Hides all tasks that contain TERM(s) preceded by a\n\t\t      minus sign (i.e. -TERM). If no TERM specified, lists entire todo.txt.\n\n\t\t    listall [TERM...]\n\t\t    lsa [TERM...]\n\t\t      Displays all the lines in todo.txt AND done.txt that contain TERM(s)\n\t\t      sorted by priority with line  numbers.  Hides all tasks that\n\t\t      contain TERM(s) preceded by a minus sign (i.e. -TERM).  If no\n\t\t      TERM specified, lists entire todo.txt AND done.txt\n\t\t      concatenated and sorted.\n\n\t\t    listaddons\n\t\t      Lists all added and overridden actions in the actions directory.\n\n\t\t    listcon [TERM...]\n\t\t    lsc [TERM...]\n\t\t      Lists all the task contexts that start with the @ sign in todo.txt.\n\t\t      If TERM specified, considers only tasks that contain TERM(s).\n\n\t\t    listfile [SRC [TERM...]]\n\t\t    lf [SRC [TERM...]]\n\t\t      Displays all the lines in SRC file located in the todo.txt directory,\n\t\t      sorted by priority with line  numbers.  If TERM specified, lists\n\t\t      all lines that contain TERM(s) in SRC file.  Hides all tasks that\n\t\t      contain TERM(s) preceded by a minus sign (i.e. -TERM).  \n\t\t      Without any arguments, the names of all text files in the todo.txt\n\t\t      directory are listed.\n\t\t\n\t\t    listpri [PRIORITIES] [TERM...]\n\t\t    lsp [PRIORITIES] [TERM...]\n\t\t      Displays all tasks prioritized PRIORITIES.\n\t\t      PRIORITIES can be a single one (A) or a range (A-C).\n\t\t      If no PRIORITIES specified, lists all prioritized tasks.\n\t\t      If TERM specified, lists only prioritized tasks that contain TERM(s).\n\t\t      Hides all tasks that contain TERM(s) preceded by a minus sign\n\t\t      (i.e. -TERM).  \n\n\t\t    listproj [TERM...]\n\t\t    lsprj [TERM...]\n\t\t      Lists all the projects (terms that start with a + sign) in\n\t\t      todo.txt.\n\t\t      If TERM specified, considers only tasks that contain TERM(s).\n\n\t\t    move ITEM# DEST [SRC]\n\t\t    mv ITEM# DEST [SRC]\n\t\t      Moves a line from source text file (SRC) to destination text file (DEST).\n\t\t      Both source and destination file must be located in the directory defined\n\t\t      in the configuration directory.  When SRC is not defined\n\t\t      it's by default todo.txt.\n\n\t\t    prepend ITEM# \"TEXT TO PREPEND\"\n\t\t    prep ITEM# \"TEXT TO PREPEND\"\n\t\t      Adds TEXT TO PREPEND to the beginning of the task on line ITEM#.\n\t\t      Quotes optional.\n\n\t\t    pri ITEM# PRIORITY\n\t\t    p ITEM# PRIORITY\n\t\t      Adds PRIORITY to task on line ITEM#.  If the task is already\n\t\t      prioritized, replaces current priority with new PRIORITY.\n\t\t      PRIORITY must be a letter between A and Z.\n\n\t\t    replace ITEM# \"UPDATED TODO\"\n\t\t      Replaces task on line ITEM# with UPDATED TODO.\n\n\t\t    report\n\t\t      Adds the number of open tasks and done tasks to report.txt.\n\n\t\t    shorthelp\n\t\t      List the one-line usage of all built-in and add-on actions.\n\n\tEndActionsHelp\n}\n\naddonHelp()\n{\n    if [ -d \"$TODO_ACTIONS_DIR\" ]; then\n        didPrintAddonActionsHeader=\n        for action in \"$TODO_ACTIONS_DIR\"/*\n        do\n            if [ -f \"$action\" -a -x \"$action\" ]; then\n                if [ ! \"$didPrintAddonActionsHeader\" ]; then\n                    cat <<-EndAddonActionsHeader\n\t\t  Add-on Actions:\n\tEndAddonActionsHeader\n                    didPrintAddonActionsHeader=1\n                fi\n                \"$action\" usage\n            elif [ -d \"$action\" -a -x \"$action/$(basename $action)\" ]; then\n                if [ ! \"$didPrintAddonActionsHeader\" ]; then\n                    cat <<-EndAddonActionsHeader\n\t\t  Add-on Actions:\n\tEndAddonActionsHeader\n                    didPrintAddonActionsHeader=1\n                fi\n                \"$action/$(basename $action)\" usage\n            fi\n        done\n    fi\n}\n\nactionUsage()\n{\n    for actionName\n    do\n        action=\"${TODO_ACTIONS_DIR}/${actionName}\"\n        if [ -f \"$action\" -a -x \"$action\" ]; then\n            \"$action\" usage\n        elif [ -d \"$action\" -a -x \"$action/$(basename $action)\" ]; then\n            \"$action/$(basename $action)\" usage\n        else\n            builtinActionUsage=$(actionsHelp | sed -n -e \"/^    ${actionName//\\//\\\\/} /,/^\\$/p\" -e \"/^    ${actionName//\\//\\\\/}$/,/^\\$/p\")\n            if [ \"$builtinActionUsage\" ]; then\n                echo \"$builtinActionUsage\"\n                echo\n            else\n                die \"TODO: No action \\\"${actionName}\\\" exists.\"\n            fi\n        fi\n    done\n}\n\ndieWithHelp()\n{\n    case \"$1\" in\n        help)       help;;\n        shorthelp)  shorthelp;;\n    esac\n    shift\n\n    die \"$@\"\n}\ndie()\n{\n    echo \"$*\"\n    exit 1\n}\n\ncleaninput()\n{\n    # Parameters:    When $1 = \"for sed\", performs additional escaping for use\n    #                in sed substitution with \"|\" separators.\n    # Precondition:  $input contains text to be cleaned.\n    # Postcondition: Modifies $input.\n\n    # Replace CR and LF with space; tasks always comprise a single line.\n    input=${input//$'\\r'/ }\n    input=${input//$'\\n'/ }\n\n    if [ \"$1\" = \"for sed\" ]; then\n        # This action uses sed with \"|\" as the substitution separator, and & as\n        # the matched string; these must be escaped.\n        # Backslashes must be escaped, too, and before the other stuff.\n        input=${input//\\\\/\\\\\\\\}\n        input=${input//|/\\\\|}\n        input=${input//&/\\\\&}\n    fi\n}\n\ngetPrefix()\n{\n    # Parameters:    $1: todo file; empty means $TODO_FILE.\n    # Returns:       Uppercase FILE prefix to be used in place of \"TODO:\" where\n    #                a different todo file can be specified.\n    local base=$(basename \"${1:-$TODO_FILE}\")\n    echo \"${base%%.[^.]*}\" | tr 'a-z' 'A-Z'\n}\n\ngetTodo()\n{\n    # Parameters:    $1: task number\n    #                $2: Optional todo file\n    # Precondition:  $errmsg contains usage message.\n    # Postcondition: $todo contains task text.\n\n    local item=$1\n    [ -z \"$item\" ] && die \"$errmsg\"\n    [ \"${item//[0-9]/}\" ] && die \"$errmsg\"\n\n    todo=$(sed \"$item!d\" \"${2:-$TODO_FILE}\")\n    [ -z \"$todo\" ] && die \"$(getPrefix \"$2\"): No task $item.\"\n}\ngetNewtodo()\n{\n    # Parameters:    $1: task number\n    #                $2: Optional todo file\n    # Precondition:  None.\n    # Postcondition: $newtodo contains task text.\n\n    local item=$1\n    [ -z \"$item\" ] && die 'Programming error: $item should exist.'\n    [ \"${item//[0-9]/}\" ] && die 'Programming error: $item should be numeric.'\n\n    newtodo=$(sed \"$item!d\" \"${2:-$TODO_FILE}\")\n    [ -z \"$newtodo\" ] && die \"$(getPrefix \"$2\"): No updated task $item.\"\n}\n\nreplaceOrPrepend()\n{\n  action=$1; shift\n  case \"$action\" in\n    replace)\n      backref=\n      querytext=\"Replacement: \"\n      ;;\n    prepend)\n      backref=' &'\n      querytext=\"Prepend: \"\n      ;;\n  esac\n  shift; item=$1; shift\n  getTodo \"$item\"\n\n  if [[ -z \"$1\" && $TODOTXT_FORCE = 0 ]]; then\n    echo -n \"$querytext\"\n    read input\n  else\n    input=$*\n  fi\n\n  # Retrieve existing priority and prepended date\n  local -r priAndDateExpr='^\\((.) \\)\\{0,1\\}\\([0-9]\\{2,4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} \\)\\{0,1\\}'\n  priority=$(sed -e \"$item!d\" -e \"${item}s/${priAndDateExpr}.*/\\\\1/\" \"$TODO_FILE\")\n  prepdate=$(sed -e \"$item!d\" -e \"${item}s/${priAndDateExpr}.*/\\\\2/\" \"$TODO_FILE\")\n\n  if [ \"$prepdate\" -a \"$action\" = \"replace\" ] && [ \"$(echo \"$input\"|sed -e \"s/${priAndDateExpr}.*/\\\\1\\\\2/\")\" ]; then\n      # If the replaced text starts with a [priority +] date, it will replace\n      # the existing date, too.\n    prepdate=\n  fi\n\n  # Temporarily remove any existing priority and prepended date, perform the\n  # change (replace/prepend) and re-insert the existing priority and prepended\n  # date again.\n  cleaninput \"for sed\"\n  sed -i.bak -e \"$item s/^${priority}${prepdate}//\" -e \"$item s|^.*|${priority}${prepdate}${input}${backref}|\" \"$TODO_FILE\"\n  if [ $TODOTXT_VERBOSE -gt 0 ]; then\n    getNewtodo \"$item\"\n    case \"$action\" in\n      replace)\n        echo \"$item $todo\"\n        echo \"TODO: Replaced task with:\"\n        echo \"$item $newtodo\"\n        ;;\n      prepend)\n        echo \"$item $newtodo\"\n        ;;\n    esac\n  fi\n}\n\n#Preserving environment variables so they don't get clobbered by the config file\nOVR_TODOTXT_AUTO_ARCHIVE=\"$TODOTXT_AUTO_ARCHIVE\"\nOVR_TODOTXT_FORCE=\"$TODOTXT_FORCE\"\nOVR_TODOTXT_PRESERVE_LINE_NUMBERS=\"$TODOTXT_PRESERVE_LINE_NUMBERS\"\nOVR_TODOTXT_PLAIN=\"$TODOTXT_PLAIN\"\nOVR_TODOTXT_DATE_ON_ADD=\"$TODOTXT_DATE_ON_ADD\"\nOVR_TODOTXT_DISABLE_FILTER=\"$TODOTXT_DISABLE_FILTER\"\nOVR_TODOTXT_VERBOSE=\"$TODOTXT_VERBOSE\"\nOVR_TODOTXT_DEFAULT_ACTION=\"$TODOTXT_DEFAULT_ACTION\"\nOVR_TODOTXT_SORT_COMMAND=\"$TODOTXT_SORT_COMMAND\"\nOVR_TODOTXT_FINAL_FILTER=\"$TODOTXT_FINAL_FILTER\"\n\n# Prevent GREP_OPTIONS from malforming grep's output\nGREP_OPTIONS=\"\"\n\n# == PROCESS OPTIONS ==\nwhile getopts \":fhpcnNaAtTvVx+@Pd:\" Option\ndo\n  case $Option in\n    '@' )\n        ## HIDE_CONTEXT_NAMES starts at zero (false); increment it to one\n        ##   (true) the first time this flag is seen. Each time the flag\n        ##   is seen after that, increment it again so that an even\n        ##   number shows context names and an odd number hides context\n        ##   names.\n        : $(( HIDE_CONTEXT_NAMES++ ))\n        if [ $(( $HIDE_CONTEXT_NAMES % 2 )) -eq 0 ]\n        then\n            ## Zero or even value -- show context names\n            unset HIDE_CONTEXTS_SUBSTITUTION\n        else\n            ## One or odd value -- hide context names\n            export HIDE_CONTEXTS_SUBSTITUTION='[[:space:]]@[[:graph:]]\\{1,\\}'\n        fi\n        ;;\n    '+' )\n        ## HIDE_PROJECT_NAMES starts at zero (false); increment it to one\n        ##   (true) the first time this flag is seen. Each time the flag\n        ##   is seen after that, increment it again so that an even\n        ##   number shows project names and an odd number hides project\n        ##   names.\n        : $(( HIDE_PROJECT_NAMES++ ))\n        if [ $(( $HIDE_PROJECT_NAMES % 2 )) -eq 0 ]\n        then\n            ## Zero or even value -- show project names\n            unset HIDE_PROJECTS_SUBSTITUTION\n        else\n            ## One or odd value -- hide project names\n            export HIDE_PROJECTS_SUBSTITUTION='[[:space:]][+][[:graph:]]\\{1,\\}'\n        fi\n        ;;\n    a )\n        OVR_TODOTXT_AUTO_ARCHIVE=0\n        ;;\n    A )\n        OVR_TODOTXT_AUTO_ARCHIVE=1\n        ;;\n    c )\n        OVR_TODOTXT_PLAIN=0\n        ;;\n    d )\n        TODOTXT_CFG_FILE=$OPTARG\n        ;;\n    f )\n        OVR_TODOTXT_FORCE=1\n        ;;\n    h )\n        # Short-circuit option parsing and forward to the action.\n        # Cannot just invoke shorthelp() because we need the configuration\n        # processed to locate the add-on actions directory.\n        set -- '-h' 'shorthelp'\n        OPTIND=2\n        ;;\n    n )\n        OVR_TODOTXT_PRESERVE_LINE_NUMBERS=0\n        ;;\n    N )\n        OVR_TODOTXT_PRESERVE_LINE_NUMBERS=1\n        ;;\n    p )\n        OVR_TODOTXT_PLAIN=1\n        ;;\n    P )\n        ## HIDE_PRIORITY_LABELS starts at zero (false); increment it to one\n        ##   (true) the first time this flag is seen. Each time the flag\n        ##   is seen after that, increment it again so that an even\n        ##   number shows priority labels and an odd number hides priority\n        ##   labels.\n        : $(( HIDE_PRIORITY_LABELS++ ))\n        if [ $(( $HIDE_PRIORITY_LABELS % 2 )) -eq 0 ]\n        then\n            ## Zero or even value -- show priority labels\n            unset HIDE_PRIORITY_SUBSTITUTION\n        else\n            ## One or odd value -- hide priority labels\n            export HIDE_PRIORITY_SUBSTITUTION=\"([A-Z])[[:space:]]\"\n        fi\n        ;;\n    t )\n        OVR_TODOTXT_DATE_ON_ADD=1\n        ;;\n    T )\n        OVR_TODOTXT_DATE_ON_ADD=0\n        ;;\n    v )\n        : $(( TODOTXT_VERBOSE++ ))\n        ;;\n    V )\n        version\n        ;;\n    x )\n        OVR_TODOTXT_DISABLE_FILTER=1\n        ;;\n  esac\ndone\nshift $(($OPTIND - 1))\n\n# defaults if not yet defined\nTODOTXT_VERBOSE=${TODOTXT_VERBOSE:-1}\nTODOTXT_PLAIN=${TODOTXT_PLAIN:-0}\nTODOTXT_CFG_FILE=${TODOTXT_CFG_FILE:-$HOME/.todo/config}\nTODOTXT_FORCE=${TODOTXT_FORCE:-0}\nTODOTXT_PRESERVE_LINE_NUMBERS=${TODOTXT_PRESERVE_LINE_NUMBERS:-1}\nTODOTXT_AUTO_ARCHIVE=${TODOTXT_AUTO_ARCHIVE:-1}\nTODOTXT_DATE_ON_ADD=${TODOTXT_DATE_ON_ADD:-0}\nTODOTXT_DEFAULT_ACTION=${TODOTXT_DEFAULT_ACTION:-}\nTODOTXT_SORT_COMMAND=${TODOTXT_SORT_COMMAND:-env LC_COLLATE=C sort -f -k2}\nTODOTXT_DISABLE_FILTER=${TODOTXT_DISABLE_FILTER:-}\nTODOTXT_FINAL_FILTER=${TODOTXT_FINAL_FILTER:-cat}\nTODOTXT_GLOBAL_CFG_FILE=${TODOTXT_GLOBAL_CFG_FILE:-/etc/todo/config}\n\n# Export all TODOTXT_* variables\nexport ${!TODOTXT_@}\n\n# Default color map\nexport NONE=''\nexport BLACK='\\\\033[0;30m'\nexport RED='\\\\033[0;31m'\nexport GREEN='\\\\033[0;32m'\nexport BROWN='\\\\033[0;33m'\nexport BLUE='\\\\033[0;34m'\nexport PURPLE='\\\\033[0;35m'\nexport CYAN='\\\\033[0;36m'\nexport LIGHT_GREY='\\\\033[0;37m'\nexport DARK_GREY='\\\\033[1;30m'\nexport LIGHT_RED='\\\\033[1;31m'\nexport LIGHT_GREEN='\\\\033[1;32m'\nexport YELLOW='\\\\033[1;33m'\nexport LIGHT_BLUE='\\\\033[1;34m'\nexport LIGHT_PURPLE='\\\\033[1;35m'\nexport LIGHT_CYAN='\\\\033[1;36m'\nexport WHITE='\\\\033[1;37m'\nexport DEFAULT='\\\\033[0m'\n\n# Default priority->color map.\nexport PRI_A=$YELLOW        # color for A priority\nexport PRI_B=$GREEN         # color for B priority\nexport PRI_C=$LIGHT_BLUE    # color for C priority\nexport PRI_X=$WHITE         # color unless explicitly defined\n\n# Default project and context colors.\nexport COLOR_PROJECT=$NONE\nexport COLOR_CONTEXT=$NONE\n\n# Default highlight colors.\nexport COLOR_DONE=$LIGHT_GREY   # color for done (but not yet archived) tasks\n\n# Default sentence delimiters for todo.sh append.\n# If the text to be appended to the task begins with one of these characters, no\n# whitespace is inserted in between. This makes appending to an enumeration\n# (todo.sh add 42 \", foo\") syntactically correct.\nexport SENTENCE_DELIMITERS=',.:;'\n\n[ -e \"$TODOTXT_CFG_FILE\" ] || {\n    CFG_FILE_ALT=\"$HOME/todo.cfg\"\n\n    if [ -e \"$CFG_FILE_ALT\" ]\n    then\n        TODOTXT_CFG_FILE=\"$CFG_FILE_ALT\"\n    fi\n}\n\n[ -e \"$TODOTXT_CFG_FILE\" ] || {\n    CFG_FILE_ALT=\"$HOME/.todo.cfg\"\n\n    if [ -e \"$CFG_FILE_ALT\" ]\n    then\n        TODOTXT_CFG_FILE=\"$CFG_FILE_ALT\"\n    fi\n}\n\n[ -e \"$TODOTXT_CFG_FILE\" ] || {\n    CFG_FILE_ALT=$(dirname \"$0\")\"/todo.cfg\"\n\n    if [ -e \"$CFG_FILE_ALT\" ]\n    then\n        TODOTXT_CFG_FILE=\"$CFG_FILE_ALT\"\n    fi\n}\n\n[ -e \"$TODOTXT_CFG_FILE\" ] || {\n    CFG_FILE_ALT=\"$TODOTXT_GLOBAL_CFG_FILE\"\n\n    if [ -e \"$CFG_FILE_ALT\" ]\n    then\n        TODOTXT_CFG_FILE=\"$CFG_FILE_ALT\"\n    fi\n}\n\n\nif [ -z \"$TODO_ACTIONS_DIR\" -o ! -d \"$TODO_ACTIONS_DIR\" ]\nthen\n    TODO_ACTIONS_DIR=\"$HOME/.todo/actions\"\n    export TODO_ACTIONS_DIR\nfi\n\n[ -d \"$TODO_ACTIONS_DIR\" ] || {\n    TODO_ACTIONS_DIR_ALT=\"$HOME/.todo.actions.d\"\n\n    if [ -d \"$TODO_ACTIONS_DIR_ALT\" ]\n    then\n        TODO_ACTIONS_DIR=\"$TODO_ACTIONS_DIR_ALT\"\n    fi\n}\n\n# === SANITY CHECKS (thanks Karl!) ===\n[ -r \"$TODOTXT_CFG_FILE\" ] || dieWithHelp \"$1\" \"Fatal Error: Cannot read configuration file $TODOTXT_CFG_FILE\"\n\n. \"$TODOTXT_CFG_FILE\"\n\n# === APPLY OVERRIDES\nif [ -n \"$OVR_TODOTXT_AUTO_ARCHIVE\" ] ; then\n  TODOTXT_AUTO_ARCHIVE=\"$OVR_TODOTXT_AUTO_ARCHIVE\"\nfi\nif [ -n \"$OVR_TODOTXT_FORCE\" ] ; then\n  TODOTXT_FORCE=\"$OVR_TODOTXT_FORCE\"\nfi\nif [ -n \"$OVR_TODOTXT_PRESERVE_LINE_NUMBERS\" ] ; then\n  TODOTXT_PRESERVE_LINE_NUMBERS=\"$OVR_TODOTXT_PRESERVE_LINE_NUMBERS\"\nfi\nif [ -n \"$OVR_TODOTXT_PLAIN\" ] ; then\n  TODOTXT_PLAIN=\"$OVR_TODOTXT_PLAIN\"\nfi\nif [ -n \"$OVR_TODOTXT_DATE_ON_ADD\" ] ; then\n  TODOTXT_DATE_ON_ADD=\"$OVR_TODOTXT_DATE_ON_ADD\"\nfi\nif [ -n \"$OVR_TODOTXT_DISABLE_FILTER\" ] ; then\n  TODOTXT_DISABLE_FILTER=\"$OVR_TODOTXT_DISABLE_FILTER\"\nfi\nif [ -n \"$OVR_TODOTXT_VERBOSE\" ] ; then\n  TODOTXT_VERBOSE=\"$OVR_TODOTXT_VERBOSE\"\nfi\nif [ -n \"$OVR_TODOTXT_DEFAULT_ACTION\" ] ; then\n  TODOTXT_DEFAULT_ACTION=\"$OVR_TODOTXT_DEFAULT_ACTION\"\nfi\nif [ -n \"$OVR_TODOTXT_SORT_COMMAND\" ] ; then\n  TODOTXT_SORT_COMMAND=\"$OVR_TODOTXT_SORT_COMMAND\"\nfi\nif [ -n \"$OVR_TODOTXT_FINAL_FILTER\" ] ; then\n  TODOTXT_FINAL_FILTER=\"$OVR_TODOTXT_FINAL_FILTER\"\nfi\n\nACTION=${1:-$TODOTXT_DEFAULT_ACTION}\n\n[ -z \"$ACTION\" ]    && usage\n[ -d \"$TODO_DIR\" ]  || mkdir -p $TODO_DIR 2> /dev/null || dieWithHelp \"$1\" \"Fatal Error: $TODO_DIR is not a directory\"\n( cd \"$TODO_DIR\" )  || dieWithHelp \"$1\" \"Fatal Error: Unable to cd to $TODO_DIR\"\n\n[ -f \"$TODO_FILE\" -o -c \"$TODO_FILE\" ] || > \"$TODO_FILE\"\n[ -f \"$DONE_FILE\" -o -c \"$DONE_FILE\" ] || > \"$DONE_FILE\"\n[ -f \"$REPORT_FILE\" -o -c \"$REPORT_FILE\" ] || > \"$REPORT_FILE\"\n\nif [ $TODOTXT_PLAIN = 1 ]; then\n    for clr in ${!PRI_@}; do\n        export $clr=$NONE\n    done\n    PRI_X=$NONE\n    DEFAULT=$NONE\n    COLOR_DONE=$NONE\n    COLOR_PROJECT=$NONE\n    COLOR_CONTEXT=$NONE\nfi\n\n[[ \"$HIDE_PROJECTS_SUBSTITUTION\" ]] && COLOR_PROJECT=\"$NONE\"\n[[ \"$HIDE_CONTEXTS_SUBSTITUTION\" ]] && COLOR_CONTEXT=\"$NONE\"\n\n_addto() {\n    file=\"$1\"\n    input=\"$2\"\n    cleaninput\n\n    if [[ $TODOTXT_DATE_ON_ADD = 1 ]]; then\n        now=$(date '+%Y-%m-%d')\n        input=$(echo \"$input\" | sed -e 's/^\\(([A-Z]) \\)\\{0,1\\}/\\1'\"$now /\")\n    fi\n    echo \"$input\" >> \"$file\"\n    if [ $TODOTXT_VERBOSE -gt 0 ]; then\n        TASKNUM=$(sed -n '$ =' \"$file\")\n        echo \"$TASKNUM $input\"\n        echo \"$(getPrefix \"$file\"): $TASKNUM added.\"\n    fi\n}\n\nshellquote()\n{\n    typeset -r qq=\\'; printf %s\\\\n \"'${1//\\'/${qq}\\\\${qq}${qq}}'\";\n}\n\nfiltercommand()\n{\n    filter=${1:-}\n    shift\n    post_filter=${1:-}\n    shift\n\n    for search_term\n    do\n        ## See if the first character of $search_term is a dash\n        if [ \"${search_term:0:1}\" != '-' ]\n        then\n            ## First character isn't a dash: hide lines that don't match\n            ## this $search_term\n            filter=\"${filter:-}${filter:+ | }grep -i $(shellquote \"$search_term\")\"\n        else\n            ## First character is a dash: hide lines that match this\n            ## $search_term\n            #\n            ## Remove the first character (-) before adding to our filter command\n            filter=\"${filter:-}${filter:+ | }grep -v -i $(shellquote \"${search_term:1}\")\"\n        fi\n    done\n\n    [ -n \"$post_filter\" ] && {\n        filter=\"${filter:-}${filter:+ | }${post_filter:-}\"\n    }\n\n    printf %s \"$filter\"\n}\n\n_list() {\n    local FILE=\"$1\"\n    ## If the file starts with a \"/\" use absolute path. Otherwise,\n    ## try to find it in either $TODO_DIR or using a relative path\n    if [ \"${1:0:1}\" == / ]; then\n        ## Absolute path\n        src=\"$FILE\"\n    elif [ -f \"$TODO_DIR/$FILE\" ]; then\n        ## Path relative to todo.sh directory\n        src=\"$TODO_DIR/$FILE\"\n    elif [ -f \"$FILE\" ]; then\n        ## Path relative to current working directory\n        src=\"$FILE\"\n    elif [ -f \"$TODO_DIR/${FILE}.txt\" ]; then\n        ## Path relative to todo.sh directory, missing file extension\n        src=\"$TODO_DIR/${FILE}.txt\"\n    else\n        die \"TODO: File $FILE does not exist.\"\n    fi\n\n    ## Get our search arguments, if any\n    shift ## was file name, new $1 is first search term\n\n    _format \"$src\" '' \"$@\"\n\n    if [ $TODOTXT_VERBOSE -gt 0 ]; then\n        echo \"--\"\n        echo \"$(getPrefix \"$src\"): ${NUMTASKS:-0} of ${TOTALTASKS:-0} tasks shown\"\n    fi\n}\ngetPadding()\n{\n    ## We need one level of padding for each power of 10 $LINES uses.\n    LINES=$(sed -n '$ =' \"${1:-$TODO_FILE}\")\n    printf %s ${#LINES}\n}\n_format()\n{\n    # Parameters:    $1: todo input file; when empty formats stdin\n    #                $2: ITEM# number width; if empty auto-detects from $1 / $TODO_FILE.\n    # Precondition:  None\n    # Postcondition: $NUMTASKS and $TOTALTASKS contain statistics (unless $TODOTXT_VERBOSE=0).\n\n    FILE=$1\n    shift\n\n    ## Figure out how much padding we need to use, unless this was passed to us.\n    PADDING=${1:-$(getPadding \"$FILE\")}\n    shift\n\n    ## Number the file, then run the filter command,\n    ## then sort and mangle output some more\n    if [[ $TODOTXT_DISABLE_FILTER = 1 ]]; then\n        TODOTXT_FINAL_FILTER=\"cat\"\n    fi\n    items=$(\n        if [ \"$FILE\" ]; then\n            sed = \"$FILE\"\n        else\n            sed =\n        fi                                                      \\\n        | sed -e '''\n            N\n            s/^/     /\n            s/ *\\([ 0-9]\\{'\"$PADDING\"',\\}\\)\\n/\\1 /\n            /^[ 0-9]\\{1,\\} *$/d\n         '''\n    )\n\n    ## Build and apply the filter.\n    filter_command=$(filtercommand \"${pre_filter_command:-}\" \"${post_filter_command:-}\" \"$@\")\n    if [ \"${filter_command}\" ]; then\n        filtered_items=$(echo -n \"$items\" | eval \"${filter_command}\")\n    else\n        filtered_items=$items\n    fi\n    filtered_items=$(\n        echo -n \"$filtered_items\"                              \\\n        | sed '''\n            s/^     /00000/;\n            s/^    /0000/;\n            s/^   /000/;\n            s/^  /00/;\n            s/^ /0/;\n          ''' \\\n        | eval ${TODOTXT_SORT_COMMAND}                                        \\\n        | awk '''\n            function highlight(colorVar,      color) {\n                color = ENVIRON[colorVar]\n                gsub(/\\\\+033/, \"\\033\", color)\n                return color\n            }\n            {\n                clr = \"\"\n                if (match($0, /^[0-9]+ x /)) {\n                    clr = highlight(\"COLOR_DONE\")\n                } else if (match($0, /^[0-9]+ \\([A-Z]\\) /)) {\n                    clr = highlight(\"PRI_\" substr($0, RSTART + RLENGTH - 3, 1))\n                    clr = (clr ? clr : highlight(\"PRI_X\"))\n                    if (ENVIRON[\"HIDE_PRIORITY_SUBSTITUTION\"] != \"\") {\n                        $0 = substr($0, 1, RLENGTH - 4) substr($0, RSTART + RLENGTH)\n                    }\n                }\n                end_clr = (clr ? highlight(\"DEFAULT\") : \"\")\n\n                prj_beg = highlight(\"COLOR_PROJECT\")\n                prj_end = (prj_beg ? (highlight(\"DEFAULT\") clr) : \"\")\n\n                ctx_beg = highlight(\"COLOR_CONTEXT\")\n                ctx_end = (ctx_beg ? (highlight(\"DEFAULT\") clr) : \"\")\n\n                gsub(/[ \\t][ \\t]*/, \"\\n&\\n\")\n                len = split($0, words, /\\n/)\n\n                printf \"%s\", clr\n                for (i = 1; i <= len; ++i) {\n                    if (words[i] ~ /^[+].*[A-Za-z0-9_]$/) {\n                        printf \"%s\", prj_beg words[i] prj_end\n                    } else if (words[i] ~ /^[@].*[A-Za-z0-9_]$/) {\n                        printf \"%s\", ctx_beg words[i] ctx_end\n                    } else {\n                        printf \"%s\", words[i]\n                    }\n                }\n                printf \"%s\\n\", end_clr\n            }\n          '''  \\\n        | sed '''\n            s/'\"${HIDE_PROJECTS_SUBSTITUTION:-^}\"'//g\n            s/'\"${HIDE_CONTEXTS_SUBSTITUTION:-^}\"'//g\n            s/'\"${HIDE_CUSTOM_SUBSTITUTION:-^}\"'//g\n          '''                                                   \\\n        | eval ${TODOTXT_FINAL_FILTER}                          \\\n    )\n    [ \"$filtered_items\" ] && echo \"$filtered_items\"\n\n    if [ $TODOTXT_VERBOSE -gt 0 ]; then\n        NUMTASKS=$( echo -n \"$filtered_items\" | sed -n '$ =' )\n        TOTALTASKS=$( echo -n \"$items\" | sed -n '$ =' )\n    fi\n    if [ $TODOTXT_VERBOSE -gt 1 ]; then\n        echo \"TODO DEBUG: Filter Command was: ${filter_command:-cat}\"\n    fi\n}\n\nlistWordsWithSigil()\n{\n    sigil=$1\n    shift\n\n    FILE=$TODO_FILE\n    [ \"$TODOTXT_SOURCEVAR\" ] && eval \"FILE=$TODOTXT_SOURCEVAR\"\n    eval \"$(filtercommand 'cat \"${FILE[@]}\"' '' \"$@\")\" | grep -o \"[^ ]*${sigil}[^ ]\\\\+\" | grep \"^$sigil\" | sort -u\n}\n\nexport -f cleaninput getPrefix getTodo getNewtodo shellquote filtercommand _list listWordsWithSigil getPadding _format die\n\n# == HANDLE ACTION ==\naction=$( printf \"%s\\n\" \"$ACTION\" | tr 'A-Z' 'a-z' )\n\n## If the first argument is \"command\", run the rest of the arguments\n## using todo.sh builtins.\n## Else, run a actions script with the name of the command if it exists\n## or fallback to using a builtin\nif [ \"$action\" == command ]\nthen\n    ## Get rid of \"command\" from arguments list\n    shift\n    ## Reset action to new first argument\n    action=$( printf \"%s\\n\" \"$1\" | tr 'A-Z' 'a-z' )\nelif [ -d \"$TODO_ACTIONS_DIR/$action\" -a -x \"$TODO_ACTIONS_DIR/$action/$action\" ]\nthen\n    \"$TODO_ACTIONS_DIR/$action/$action\" \"$@\"\n    exit $?\nelif [ -d \"$TODO_ACTIONS_DIR\" -a -x \"$TODO_ACTIONS_DIR/$action\" ]\nthen\n    \"$TODO_ACTIONS_DIR/$action\" \"$@\"\n    exit $?\nfi\n\n## Only run if $action isn't found in .todo.actions.d\ncase $action in\n\"add\" | \"a\")\n    if [[ -z \"$2\" && $TODOTXT_FORCE = 0 ]]; then\n        echo -n \"Add: \"\n        read input\n    else\n        [ -z \"$2\" ] && die \"usage: $TODO_SH add \\\"TODO ITEM\\\"\"\n        shift\n        input=$*\n    fi\n    _addto \"$TODO_FILE\" \"$input\"\n    ;;\n\n\"addm\")\n    if [[ -z \"$2\" && $TODOTXT_FORCE = 0 ]]; then\n        echo -n \"Add: \"\n        read input\n    else\n        [ -z \"$2\" ] && die \"usage: $TODO_SH addm \\\"TODO ITEM\\\"\"\n        shift\n        input=$*\n    fi\n\n    # Set Internal Field Seperator as newline so we can \n    # loop across multiple lines\n    SAVEIFS=$IFS\n    IFS=$'\\n'\n\n    # Treat each line seperately\n    for line in $input ; do\n        _addto \"$TODO_FILE\" \"$line\"\n    done\n    IFS=$SAVEIFS\n    ;;\n\n\"addto\" )\n    [ -z \"$2\" ] && die \"usage: $TODO_SH addto DEST \\\"TODO ITEM\\\"\"\n    dest=\"$TODO_DIR/$2\"\n    [ -z \"$3\" ] && die \"usage: $TODO_SH addto DEST \\\"TODO ITEM\\\"\"\n    shift\n    shift\n    input=$*\n\n    if [ -f \"$dest\" ]; then\n        _addto \"$dest\" \"$input\"\n    else\n        die \"TODO: Destination file $dest does not exist.\"\n    fi\n    ;;\n\n\"append\" | \"app\" )\n    errmsg=\"usage: $TODO_SH append ITEM# \\\"TEXT TO APPEND\\\"\"\n    shift; item=$1; shift\n    getTodo \"$item\"\n\n    if [[ -z \"$1\" && $TODOTXT_FORCE = 0 ]]; then\n        echo -n \"Append: \"\n        read input\n    else\n        input=$*\n    fi\n    case \"$input\" in\n      [$SENTENCE_DELIMITERS]*)  appendspace=;;\n      *)                        appendspace=\" \";;\n    esac\n    cleaninput \"for sed\"\n\n    if sed -i.bak $item\" s|^.*|&${appendspace}${input}|\" \"$TODO_FILE\"; then\n        if [ $TODOTXT_VERBOSE -gt 0 ]; then\n            getNewtodo \"$item\"\n            echo \"$item $newtodo\"\n\tfi\n    else\n        die \"TODO: Error appending task $item.\"\n    fi\n    ;;\n\n\"archive\" )\n    # defragment blank lines\n    sed -i.bak -e '/./!d' \"$TODO_FILE\"\n    [ $TODOTXT_VERBOSE -gt 0 ] && grep \"^x \" \"$TODO_FILE\"\n    grep \"^x \" \"$TODO_FILE\" >> \"$DONE_FILE\"\n    sed -i.bak '/^x /d' \"$TODO_FILE\"\n    if [ $TODOTXT_VERBOSE -gt 0 ]; then\n\techo \"TODO: $TODO_FILE archived.\"\n    fi\n    ;;\n\n\"del\" | \"rm\" )\n    # replace deleted line with a blank line when TODOTXT_PRESERVE_LINE_NUMBERS is 1\n    errmsg=\"usage: $TODO_SH del ITEM# [TERM]\"\n    item=$2\n    getTodo \"$item\"\n\n    if [ -z \"$3\" ]; then\n        if  [ $TODOTXT_FORCE = 0 ]; then\n            echo \"Delete '$todo'?  (y/n)\"\n            read ANSWER\n        else\n            ANSWER=\"y\"\n        fi\n        if [ \"$ANSWER\" = \"y\" ]; then\n            if [ $TODOTXT_PRESERVE_LINE_NUMBERS = 0 ]; then\n                # delete line (changes line numbers)\n                sed -i.bak -e $item\"s/^.*//\" -e '/./!d' \"$TODO_FILE\"\n            else\n                # leave blank line behind (preserves line numbers)\n                sed -i.bak -e $item\"s/^.*//\" \"$TODO_FILE\"\n            fi\n            if [ $TODOTXT_VERBOSE -gt 0 ]; then\n                echo \"$item $todo\"\n                echo \"TODO: $item deleted.\"\n            fi\n        else\n            echo \"TODO: No tasks were deleted.\"\n        fi\n    else\n        sed -i.bak \\\n            -e $item\"s/^\\((.) \\)\\{0,1\\} *$3 */\\1/g\" \\\n            -e $item\"s/ *$3 *\\$//g\" \\\n            -e $item\"s/  *$3 */ /g\" \\\n            -e $item\"s/ *$3  */ /g\" \\\n            -e $item\"s/$3//g\" \\\n            \"$TODO_FILE\"\n        getNewtodo \"$item\"\n        if [ \"$todo\" = \"$newtodo\" ]; then\n            [ $TODOTXT_VERBOSE -gt 0 ] && echo \"$item $todo\"\n            die \"TODO: '$3' not found; no removal done.\"\n        fi\n        if [ $TODOTXT_VERBOSE -gt 0 ]; then\n            echo \"$item $todo\"\n            echo \"TODO: Removed '$3' from task.\"\n            echo \"$item $newtodo\"\n        fi\n    fi\n    ;;\n\n\"depri\" | \"dp\" )\n    errmsg=\"usage: $TODO_SH depri ITEM#[, ITEM#, ITEM#, ...]\"\n    shift;\n    [ $# -eq 0 ] && die \"$errmsg\"\n\n    # Split multiple depri's, if comma separated change to whitespace separated\n    # Loop the 'depri' function for each item\n    for item in ${*//,/ }; do\n        getTodo \"$item\"\n\n\tif [[ \"$todo\" = \\(?\\)\\ * ]]; then\n\t    sed -i.bak -e $item\"s/^(.) //\" \"$TODO_FILE\"\n\t    if [ $TODOTXT_VERBOSE -gt 0 ]; then\n\t\tgetNewtodo \"$item\"\n\t\techo \"$item $newtodo\"\n\t\techo \"TODO: $item deprioritized.\"\n\t    fi\n\telse\n\t    echo \"TODO: $item is not prioritized.\"\n\tfi\n    done\n    ;;\n\n\"do\" )\n    errmsg=\"usage: $TODO_SH do ITEM#[, ITEM#, ITEM#, ...]\"\n    # shift so we get arguments to the do request\n    shift;\n    [ \"$#\" -eq 0 ] && die \"$errmsg\"\n\n    # Split multiple do's, if comma separated change to whitespace separated\n    # Loop the 'do' function for each item\n    for item in ${*//,/ }; do\n        getTodo \"$item\"\n\n        # Check if this item has already been done\n        if [ \"${todo:0:2}\" != \"x \" ]; then\n            now=$(date '+%Y-%m-%d')\n            # remove priority once item is done\n            sed -i.bak $item\"s/^(.) //\" \"$TODO_FILE\"\n            sed -i.bak $item\"s|^|x $now |\" \"$TODO_FILE\"\n            if [ $TODOTXT_VERBOSE -gt 0 ]; then\n                getNewtodo \"$item\"\n                echo \"$item $newtodo\"\n                echo \"TODO: $item marked as done.\"\n\t    fi\n        else\n            echo \"TODO: $item is already marked done.\"\n        fi\n    done\n\n    if [ $TODOTXT_AUTO_ARCHIVE = 1 ]; then\n        # Recursively invoke the script to allow overriding of the archive\n        # action.\n        \"$TODO_FULL_SH\" archive\n    fi\n    ;;\n\n\"help\" )\n    shift  ## Was help; new $1 is first help topic / action name\n    if [ $# -gt 0 ]; then\n        # Don't use PAGER here; we don't expect much usage output from one / few actions.\n        actionUsage \"$@\"\n    else\n        if [ -t 1 ] ; then # STDOUT is a TTY\n            if which \"${PAGER:-less}\" >/dev/null 2>&1; then\n                # we have a working PAGER (or less as a default)\n                help | \"${PAGER:-less}\" && exit 0\n            fi\n        fi\n        help # just in case something failed above, we go ahead and just spew to STDOUT\n    fi\n    ;;\n\n\"shorthelp\" )\n    if [ -t 1 ] ; then # STDOUT is a TTY\n        if which \"${PAGER:-less}\" >/dev/null 2>&1; then\n            # we have a working PAGER (or less as a default)\n            shorthelp | \"${PAGER:-less}\" && exit 0\n        fi\n    fi\n    shorthelp # just in case something failed above, we go ahead and just spew to STDOUT\n    ;;\n\n\"list\" | \"ls\" )\n    shift  ## Was ls; new $1 is first search term\n    _list \"$TODO_FILE\" \"$@\"\n    ;;\n\n\"listall\" | \"lsa\" )\n    shift  ## Was lsa; new $1 is first search term\n\n    TOTAL=$( sed -n '$ =' \"$TODO_FILE\" )\n    PADDING=${#TOTAL}\n\n    post_filter_command=\"${post_filter_command:-}${post_filter_command:+ | }awk -v TOTAL=$TOTAL -v PADDING=$PADDING '{ \\$1 = sprintf(\\\"%\\\" PADDING \\\"d\\\", (\\$1 > TOTAL ? 0 : \\$1)); print }' \"\n    cat \"$TODO_FILE\" \"$DONE_FILE\" | TODOTXT_VERBOSE=0 _format '' \"$PADDING\" \"$@\"\n\n    if [ $TODOTXT_VERBOSE -gt 0 ]; then\n        TDONE=$( sed -n '$ =' \"$DONE_FILE\" )\n        TASKNUM=$(TODOTXT_PLAIN=1 TODOTXT_VERBOSE=0 _format \"$TODO_FILE\" 1 \"$@\" | sed -n '$ =')\n        DONENUM=$(TODOTXT_PLAIN=1 TODOTXT_VERBOSE=0 _format \"$DONE_FILE\" 1 \"$@\" | sed -n '$ =')\n        echo \"--\"\n        echo \"$(getPrefix \"$TODO_FILE\"): ${TASKNUM:-0} of ${TOTAL:-0} tasks shown\"\n        echo \"$(getPrefix \"$DONE_FILE\"): ${DONENUM:-0} of ${TDONE:-0} tasks shown\"\n        echo \"total $((TASKNUM + DONENUM)) of $((TOTAL + TDONE)) tasks shown\"\n    fi\n    ;;\n\n\"listfile\" | \"lf\" )\n    shift  ## Was listfile, next $1 is file name\n    if [ $# -eq 0 ]; then\n        [ $TODOTXT_VERBOSE -gt 0 ] && echo \"Files in the todo.txt directory:\"\n        cd \"$TODO_DIR\" && ls -1 *.txt\n    else\n        FILE=\"$1\"\n        shift  ## Was filename; next $1 is first search term\n\n        _list \"$FILE\" \"$@\"\n    fi\n    ;;\n\n\"listcon\" | \"lsc\" )\n    shift\n    listWordsWithSigil '@' \"$@\"\n    ;;\n\n\"listproj\" | \"lsprj\" )\n    shift\n    listWordsWithSigil '+' \"$@\"\n    ;;\n\n\"listpri\" | \"lsp\" )\n    shift ## was \"listpri\", new $1 is priority to list or first TERM\n\n    pri=$(printf \"%s\\n\" \"$1\" | tr 'a-z' 'A-Z' | grep -e '^[A-Z]$' -e '^[A-Z]-[A-Z]$') && shift || pri=\"A-Z\"\n    post_filter_command=\"${post_filter_command:-}${post_filter_command:+ | }grep '^ *[0-9]\\+ ([${pri}]) '\"\n    _list \"$TODO_FILE\" \"$@\"\n    ;;\n\n\"move\" | \"mv\" )\n    # replace moved line with a blank line when TODOTXT_PRESERVE_LINE_NUMBERS is 1\n    errmsg=\"usage: $TODO_SH mv ITEM# DEST [SRC]\"\n    item=$2\n    dest=\"$TODO_DIR/$3\"\n    src=\"$TODO_DIR/$4\"\n\n    [ -z \"$4\" ] && src=\"$TODO_FILE\"\n    [ -z \"$dest\" ] && die \"$errmsg\"\n\n    [ -f \"$src\" ] || die \"TODO: Source file $src does not exist.\"\n    [ -f \"$dest\" ] || die \"TODO: Destination file $dest does not exist.\"\n\n    getTodo \"$item\" \"$src\"\n    [ -z \"$todo\" ] && die \"$item: No such item in $src.\"\n    if  [ $TODOTXT_FORCE = 0 ]; then\n        echo \"Move '$todo' from $src to $dest? (y/n)\"\n        read ANSWER\n    else\n        ANSWER=\"y\"\n    fi\n    if [ \"$ANSWER\" = \"y\" ]; then\n        if [ $TODOTXT_PRESERVE_LINE_NUMBERS = 0 ]; then\n            # delete line (changes line numbers)\n            sed -i.bak -e $item\"s/^.*//\" -e '/./!d' \"$src\"\n        else\n            # leave blank line behind (preserves line numbers)\n            sed -i.bak -e $item\"s/^.*//\" \"$src\"\n        fi\n        echo \"$todo\" >> \"$dest\"\n\n        if [ $TODOTXT_VERBOSE -gt 0 ]; then\n            echo \"$item $todo\"\n            echo \"TODO: $item moved from '$src' to '$dest'.\"\n        fi\n    else\n        echo \"TODO: No tasks moved.\"\n    fi\n    ;;\n\n\"prepend\" | \"prep\" )\n    errmsg=\"usage: $TODO_SH prepend ITEM# \\\"TEXT TO PREPEND\\\"\"\n    replaceOrPrepend 'prepend' \"$@\"\n    ;;\n\n\"pri\" | \"p\" )\n    item=$2\n    newpri=$( printf \"%s\\n\" \"$3\" | tr 'a-z' 'A-Z' )\n\n    errmsg=\"usage: $TODO_SH pri ITEM# PRIORITY\nnote: PRIORITY must be anywhere from A to Z.\"\n\n    [ \"$#\" -ne 3 ] && die \"$errmsg\"\n    [[ \"$newpri\" = @([A-Z]) ]] || die \"$errmsg\"\n    getTodo \"$item\"\n\n    oldpri=\n    if [[ \"$todo\" = \\(?\\)\\ * ]]; then\n        oldpri=${todo:1:1}\n    fi\n\n    if [ \"$oldpri\" != \"$newpri\" ]; then\n        sed -i.bak -e $item\"s/^(.) //\" -e $item\"s/^/($newpri) /\" \"$TODO_FILE\"\n    fi\n    if [ $TODOTXT_VERBOSE -gt 0 ]; then\n        getNewtodo \"$item\"\n        echo \"$item $newtodo\"\n        if [ \"$oldpri\" != \"$newpri\" ]; then\n            if [ \"$oldpri\" ]; then\n                echo \"TODO: $item re-prioritized from ($oldpri) to ($newpri).\"\n            else\n                echo \"TODO: $item prioritized ($newpri).\"\n            fi\n        fi\n    fi\n    if [ \"$oldpri\" = \"$newpri\" ]; then\n        echo \"TODO: $item already prioritized ($newpri).\"\n    fi\n    ;;\n\n\"replace\" )\n    errmsg=\"usage: $TODO_SH replace ITEM# \\\"UPDATED ITEM\\\"\"\n    replaceOrPrepend 'replace' \"$@\"\n    ;;\n\n\"report\" )\n    # archive first\n    # Recursively invoke the script to allow overriding of the archive\n    # action.\n    \"$TODO_FULL_SH\" archive\n\n    TOTAL=$( sed -n '$ =' \"$TODO_FILE\" )\n    TDONE=$( sed -n '$ =' \"$DONE_FILE\" )\n    NEWDATA=\"${TOTAL:-0} ${TDONE:-0}\"\n    LASTREPORT=$(sed -ne '$p' \"$REPORT_FILE\")\n    LASTDATA=${LASTREPORT#* }   # Strip timestamp.\n    if [ \"$LASTDATA\" = \"$NEWDATA\" ]; then\n        echo \"$LASTREPORT\"\n        [ $TODOTXT_VERBOSE -gt 0 ] && echo \"TODO: Report file is up-to-date.\"\n    else\n        NEWREPORT=\"$(date +%Y-%m-%dT%T) ${NEWDATA}\"\n        echo \"${NEWREPORT}\" >> \"$REPORT_FILE\"\n        echo \"${NEWREPORT}\"\n        [ $TODOTXT_VERBOSE -gt 0 ] && echo \"TODO: Report file updated.\"\n    fi\n    ;;\n\n\"deduplicate\" )\n    if [ $TODOTXT_PRESERVE_LINE_NUMBERS = 0 ]; then\n        deduplicateSedCommand='d'\n    else\n        deduplicateSedCommand='s/^.*//; p'\n    fi\n\n    # To determine the difference when deduplicated lines are preserved, only\n    # non-empty lines must be counted.\n    originalTaskNum=$( sed -e '/./!d' \"$TODO_FILE\" | sed -n '$ =' )\n\n    # Look for duplicate lines and discard the second occurrence.\n    # We start with an empty hold space on the first line.  For each line:\n    #   G - appends newline + hold space to the pattern space\n    #   s/\\n/&&/; - double up the first new line so we catch adjacent dups\n    #   /^\\([^\\n]*\\n\\).*\\n\\1/b dedup\n    #       If the first line of the hold space shows up again later as an\n    #       entire line, it's a duplicate. Jump to the \"dedup\" label, where\n    #       either of the following is executed, depending on whether empty\n    #       lines should be preserved:\n    #       d           - Delete the current pattern space, quit this line and\n    #                     move on to the next, or:\n    #       s/^.*//; p  - Clear the task text, print this line and move on to\n    #                     the next.\n    #   s/\\n//;   - else (no duplicate), drop the doubled newline\n    #   h;        - replace the hold space with the expanded pattern space\n    #   P;        - print up to the first newline (that is, the input line)\n    #   b         - end processing of the current line\n    sed -i.bak -n \\\n        -e 'G; s/\\n/&&/; /^\\([^\\n]*\\n\\).*\\n\\1/b dedup' \\\n        -e 's/\\n//; h; P; b' \\\n        -e ':dedup' \\\n        -e \"$deduplicateSedCommand\" \\\n        \"$TODO_FILE\"\n\n    newTaskNum=$( sed -e '/./!d' \"$TODO_FILE\" | sed -n '$ =' )\n    deduplicateNum=$(( originalTaskNum - newTaskNum ))\n    if [ $deduplicateNum -eq 0 ]; then\n        echo \"TODO: No duplicate tasks found\"\n    else\n        echo \"TODO: $deduplicateNum duplicate task(s) removed\"\n    fi\n    ;;\n\n\"listaddons\" )\n    if [ -d \"$TODO_ACTIONS_DIR\" ]; then\n        cd \"$TODO_ACTIONS_DIR\" || exit $?\n        for action in *\n        do\n            if [ -f \"$action\" -a -x \"$action\" ]; then\n                echo \"$action\"\n            elif [ -d \"$action\" -a -x \"$action/$action\" ]; then\n                echo \"$action\"\n            fi\n        done\n    fi\n    ;;\n\n* )\n    usage;;\nesac\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[1431,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":12,"goalBufferRange":null,"autoscroll":false},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/Downloads/todo.txt_cli-2.10/todo.sh","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"9194f5f5f53615c264bfcecc562dc3dc0bca522c","deserializer":"TextBuffer"},{"text":"#!/bin/bash source-this-script\n[ \"$BASH_VERSION\" ] || return\n\n_todo()\n{\n    local cur prev opts\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n\n    local -r OPTS=\"-@ -@@ -+ -++ -d -f -h -p -P -PP -a -n -t -v -vv -V -x\"\n    local -r COMMANDS=\"\\\n        add a addto addm append app archive command del  \\\n        rm depri dp do help list ls listaddons listall lsa listcon  \\\n        lsc listfile lf listpri lsp listproj lsprj move \\\n        mv prepend prep pri p replace report shorthelp\"\n    local -r MOVE_COMMAND_PATTERN='^(move|mv)$'\n\n    local _todo_sh=${_todo_sh:-todo.sh}\n    local completions\n    if [ $COMP_CWORD -eq 1 ]; then\n        completions=\"$COMMANDS $(eval TODOTXT_VERBOSE=0 $_todo_sh command listaddons) $OPTS\"\n    elif [[ $COMP_CWORD -gt 2 && ( \\\n        \"${COMP_WORDS[COMP_CWORD-2]}\" =~ $MOVE_COMMAND_PATTERN || \\\n        \"${COMP_WORDS[COMP_CWORD-3]}\" =~ $MOVE_COMMAND_PATTERN ) ]]; then\n        # \"move ITEM# DEST [SRC]\" has file arguments on positions 2 and 3.\n        completions=$(eval TODOTXT_VERBOSE=0 $_todo_sh command listfile)\n    else\n        case \"$prev\" in\n            command)\n                completions=$COMMANDS;;\n            help)\n                completions=\"$COMMANDS $(eval TODOTXT_VERBOSE=0 $_todo_sh command listaddons)\";;\n            addto|listfile|lf)\n                completions=$(eval TODOTXT_VERBOSE=0 $_todo_sh command listfile);;\n            -*) completions=\"$COMMANDS $(eval TODOTXT_VERBOSE=0 $_todo_sh command listaddons) $OPTS\";;\n            *)  case \"$cur\" in\n                    +*) completions=$(eval TODOTXT_VERBOSE=0 $_todo_sh command listproj)\n                        COMPREPLY=( $( compgen -W \"$completions\" -- $cur ))\n                        [ ${#COMPREPLY[@]} -gt 0 ] && return 0\n                        # Fall back to projects extracted from done tasks.\n                        completions=$(eval 'TODOTXT_VERBOSE=0 TODOTXT_SOURCEVAR=\\$DONE_FILE' $_todo_sh command listproj)\n                        ;;\n                    @*) completions=$(eval TODOTXT_VERBOSE=0 $_todo_sh command listcon)\n                        COMPREPLY=( $( compgen -W \"$completions\" -- $cur ))\n                        [ ${#COMPREPLY[@]} -gt 0 ] && return 0\n                        # Fall back to contexts extracted from done tasks.\n                        completions=$(eval 'TODOTXT_VERBOSE=0 TODOTXT_SOURCEVAR=\\$DONE_FILE' $_todo_sh command listcon)\n                        ;;\n                    *)  if [[ \"$cur\" =~ ^[0-9]+$ ]]; then\n                            # Remove the (padded) task number; we prepend the\n                            # user-provided $cur instead.\n                            # Remove the timestamp prepended by the -t option,\n                            # and the done date (for done tasks); there's no\n                            # todo.txt option for that yet.\n                            # But keep priority and \"x\"; they're short and may\n                            # provide useful context.\n                            # Remove any trailing whitespace; the Bash\n                            # completion inserts a trailing space itself.\n                            # Finally, limit the output to a single line just as\n                            # a safety check of the ls action output.\n                            local todo=$( \\\n                                eval TODOTXT_VERBOSE=0 $_todo_sh '-@ -+ -p -x command ls \"^ *${cur} \"' | \\\n                                sed -e 's/^ *[0-9]\\{1,\\} //' -e 's/^\\((.) \\)\\{0,1\\}[0-9]\\{2,4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} /\\1/' \\\n                                    -e 's/^\\([xX] \\)\\([0-9]\\{2,4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} \\)\\{1,2\\}/\\1/' \\\n                                    -e 's/[[:space:]]*$//' \\\n                                    -e '1q' \\\n                            )\n                            # Append task text as a shell comment. This\n                            # completion can be a safety check before a\n                            # destructive todo.txt operation.\n                            [ \"$todo\" ] && COMPREPLY[0]=\"$cur # $todo\"\n                            return 0\n                        else\n                            return 0\n                        fi\n                        ;;\n                esac\n                ;;\n        esac\n    fi\n\n    COMPREPLY=( $( compgen -W \"$completions\" -- $cur ))\n    return 0\n}\ncomplete -F _todo todo.sh\n\n# If you define an alias (e.g. \"t\") to todo.sh, you need to explicitly enable\n# completion for it, too:\n#complete -F _todo t\n# It is recommended to put this line next to your alias definition in your\n# ~/.bashrc (or wherever else you're defining your alias). If you simply\n# uncomment it here, you will need to redo this on every todo.txt update!\n\n# If you have renamed the todo.sh executable, or if it is not accessible through\n# PATH, you need to add and use a wrapper completion function, like this:\n#_todoElsewhere()\n#{\n#    local _todo_sh='/path/to/todo2.sh'\n#    _todo \"$@\"\n#}\n#complete -F _todoElsewhere /path/to/todo2.sh\n\n# If you use aliases to use different configuration(s), you need to add and use\n# a wrapper completion function for each configuration if you want to complete\n# fron the actual configured task locations:\n#alias todo2='todo.sh -d \"$HOME/todo2.cfg\"'\n#_todo2()\n#{\n#    local _todo_sh='todo.sh -d \"$HOME/todo2.cfg\"'\n#    _todo \"$@\"\n#}\n#complete -F _todo2 todo2\n","markers":{"markers":{"1":{"id":1,"range":[[70,42],[70,46]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":16,"goalBufferRange":null,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/Downloads/todo.txt_cli-2.10/todo_completion","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"928659221f67e5f2e4cafaaaaa4515d135ffc908","deserializer":"TextBuffer"},{"text":"# === EDIT FILE LOCATIONS BELOW ===\n\n# Your todo.txt directory\n#export TODO_DIR=\"/Users/gina/Documents/todo\"\nexport TODO_DIR=$(dirname \"$0\")\n\n# Your todo/done/report.txt locations\nexport TODO_FILE=\"$TODO_DIR/todo.txt\"\nexport DONE_FILE=\"$TODO_DIR/done.txt\"\nexport REPORT_FILE=\"$TODO_DIR/report.txt\"\n\n# You can customize your actions directory location\n#export TODO_ACTIONS_DIR=\"$HOME/.todo.actions.d\"\n\n# == EDIT FILE LOCATIONS ABOVE ===\n\n# === COLOR MAP ===\n\n## Text coloring and formatting is done by inserting ANSI escape codes.\n## If you have re-mapped your color codes, or use the todo.txt\n## output in another output system (like Conky), you may need to\n## over-ride by uncommenting and editing these defaults.\n## If you change any of these here, you also need to uncomment\n## the defaults in the COLORS section below. Otherwise, todo.txt\n## will still use the defaults!\n\n# export BLACK='\\\\033[0;30m'\n# export RED='\\\\033[0;31m'\n# export GREEN='\\\\033[0;32m'\n# export BROWN='\\\\033[0;33m'\n# export BLUE='\\\\033[0;34m'\n# export PURPLE='\\\\033[0;35m'\n# export CYAN='\\\\033[0;36m'\n# export LIGHT_GREY='\\\\033[0;37m'\n# export DARK_GREY='\\\\033[1;30m'\n# export LIGHT_RED='\\\\033[1;31m'\n# export LIGHT_GREEN='\\\\033[1;32m'\n# export YELLOW='\\\\033[1;33m'\n# export LIGHT_BLUE='\\\\033[1;34m'\n# export LIGHT_PURPLE='\\\\033[1;35m'\n# export LIGHT_CYAN='\\\\033[1;36m'\n# export WHITE='\\\\033[1;37m'\n# export DEFAULT='\\\\033[0m'\n\n# === COLORS ===\n\n## Uncomment and edit to override these defaults.\n## Reference the constants from the color map above,\n## or use $NONE to disable highlighting.\n#\n# Priorities can be any upper-case letter.\n# A,B,C are highlighted; you can add coloring for more.\n#\n# export PRI_A=$YELLOW        # color for A priority\n# export PRI_B=$GREEN         # color for B priority\n# export PRI_C=$LIGHT_BLUE    # color for C priority\n# export PRI_D=...            # define your own\n# export PRI_X=$WHITE         # color unless explicitly defined\n\n# There is highlighting for tasks that have been done,\n# but haven't been archived yet.\n#\n# export COLOR_DONE=$LIGHT_GREY\n\n# There is highlighting for projects and contexts.\n#\n# export COLOR_PROJECT=$RED\n# export COLOR_CONTEXT=$RED\n\n# === BEHAVIOR ===\n\n## customize list output\n#\n# TODOTXT_SORT_COMMAND will filter after line numbers are\n# inserted, but before colorization, and before hiding of\n# priority, context, and project.\n#\n# export TODOTXT_SORT_COMMAND='env LC_COLLATE=C sort -f -k2'\n\n# TODOTXT_FINAL_FILTER will filter list output after colorization,\n# priority hiding, context hiding, and project hiding. That is,\n# just before the list output is displayed.\n#\n# export TODOTXT_FINAL_FILTER='cat'\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[84,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":28,"goalBufferRange":null,"autoscroll":false},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[{"patches":[{"oldRange":[[0,0],[113,0]],"newRange":[[0,0],[84,0]],"oldText":"#!/bin/bash source-this-script\n[ \"$BASH_VERSION\" ] || return\n\n_todo()\n{\n    local cur prev opts\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n\n    local -r OPTS=\"-@ -@@ -+ -++ -d -f -h -p -P -PP -a -n -t -v -vv -V -x\"\n    local -r COMMANDS=\"\\\n        add a addto addm append app archive command del  \\\n        rm depri dp do help list ls listaddons listall lsa listcon  \\\n        lsc listfile lf listpri lsp listproj lsprj move \\\n        mv prepend prep pri p replace report shorthelp\"\n    local -r MOVE_COMMAND_PATTERN='^(move|mv)$'\n\n    local _todo_sh=${_todo_sh:-todo.sh}\n    local completions\n    if [ $COMP_CWORD -eq 1 ]; then\n        completions=\"$COMMANDS $(eval TODOTXT_VERBOSE=0 $_todo_sh command listaddons) $OPTS\"\n    elif [[ $COMP_CWORD -gt 2 && ( \\\n        \"${COMP_WORDS[COMP_CWORD-2]}\" =~ $MOVE_COMMAND_PATTERN || \\\n        \"${COMP_WORDS[COMP_CWORD-3]}\" =~ $MOVE_COMMAND_PATTERN ) ]]; then\n        # \"move ITEM# DEST [SRC]\" has file arguments on positions 2 and 3.\n        completions=$(eval TODOTXT_VERBOSE=0 $_todo_sh command listfile)\n    else\n        case \"$prev\" in\n            command)\n                completions=$COMMANDS;;\n            help)\n                completions=\"$COMMANDS $(eval TODOTXT_VERBOSE=0 $_todo_sh command listaddons)\";;\n            addto|listfile|lf)\n                completions=$(eval TODOTXT_VERBOSE=0 $_todo_sh command listfile);;\n            -*) completions=\"$COMMANDS $(eval TODOTXT_VERBOSE=0 $_todo_sh command listaddons) $OPTS\";;\n            *)  case \"$cur\" in\n                    +*) completions=$(eval TODOTXT_VERBOSE=0 $_todo_sh command listproj)\n                        COMPREPLY=( $( compgen -W \"$completions\" -- $cur ))\n                        [ ${#COMPREPLY[@]} -gt 0 ] && return 0\n                        # Fall back to projects extracted from done tasks.\n                        completions=$(eval 'TODOTXT_VERBOSE=0 TODOTXT_SOURCEVAR=\\$DONE_FILE' $_todo_sh command listproj)\n                        ;;\n                    @*) completions=$(eval TODOTXT_VERBOSE=0 $_todo_sh command listcon)\n                        COMPREPLY=( $( compgen -W \"$completions\" -- $cur ))\n                        [ ${#COMPREPLY[@]} -gt 0 ] && return 0\n                        # Fall back to contexts extracted from done tasks.\n                        completions=$(eval 'TODOTXT_VERBOSE=0 TODOTXT_SOURCEVAR=\\$DONE_FILE' $_todo_sh command listcon)\n                        ;;\n                    *)  if [[ \"$cur\" =~ ^[0-9]+$ ]]; then\n                            # Remove the (padded) task number; we prepend the\n                            # user-provided $cur instead.\n                            # Remove the timestamp prepended by the -t option,\n                            # and the done date (for done tasks); there's no\n                            # todo.txt option for that yet.\n                            # But keep priority and \"x\"; they're short and may\n                            # provide useful context.\n                            # Remove any trailing whitespace; the Bash\n                            # completion inserts a trailing space itself.\n                            # Finally, limit the output to a single line just as\n                            # a safety check of the ls action output.\n                            local todo=$( \\\n                                eval TODOTXT_VERBOSE=0 $_todo_sh '-@ -+ -p -x command ls \"^ *${cur} \"' | \\\n                                sed -e 's/^ *[0-9]\\{1,\\} //' -e 's/^\\((.) \\)\\{0,1\\}[0-9]\\{2,4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} /\\1/' \\\n                                    -e 's/^\\([xX] \\)\\([0-9]\\{2,4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} \\)\\{1,2\\}/\\1/' \\\n                                    -e 's/[[:space:]]*$//' \\\n                                    -e '1q' \\\n                            )\n                            # Append task text as a shell comment. This\n                            # completion can be a safety check before a\n                            # destructive todo.txt operation.\n                            [ \"$todo\" ] && COMPREPLY[0]=\"$cur # $todo\"\n                            return 0\n                        else\n                            return 0\n                        fi\n                        ;;\n                esac\n                ;;\n        esac\n    fi\n\n    COMPREPLY=( $( compgen -W \"$completions\" -- $cur ))\n    return 0\n}\ncomplete -F _todo todo.sh\n\n# If you define an alias (e.g. \"t\") to todo.sh, you need to explicitly enable\n# completion for it, too:\n#complete -F _todo t\n# It is recommended to put this line next to your alias definition in your\n# ~/.bashrc (or wherever else you're defining your alias). If you simply\n# uncomment it here, you will need to redo this on every todo.txt update!\n\n# If you have renamed the todo.sh executable, or if it is not accessible through\n# PATH, you need to add and use a wrapper completion function, like this:\n#_todoElsewhere()\n#{\n#    local _todo_sh='/path/to/todo2.sh'\n#    _todo \"$@\"\n#}\n#complete -F _todoElsewhere /path/to/todo2.sh\n\n# If you use aliases to use different configuration(s), you need to add and use\n# a wrapper completion function for each configuration if you want to complete\n# fron the actual configured task locations:\n#alias todo2='todo.sh -d \"$HOME/todo2.cfg\"'\n#_todo2()\n#{\n#    local _todo_sh='todo.sh -d \"$HOME/todo2.cfg\"'\n#    _todo \"$@\"\n#}\n#complete -F _todo2 todo2\n","newText":"# === EDIT FILE LOCATIONS BELOW ===\n\n# Your todo.txt directory\n#export TODO_DIR=\"/Users/gina/Documents/todo\"\nexport TODO_DIR=$(dirname \"$0\")\n\n# Your todo/done/report.txt locations\nexport TODO_FILE=\"$TODO_DIR/todo.txt\"\nexport DONE_FILE=\"$TODO_DIR/done.txt\"\nexport REPORT_FILE=\"$TODO_DIR/report.txt\"\n\n# You can customize your actions directory location\n#export TODO_ACTIONS_DIR=\"$HOME/.todo.actions.d\"\n\n# == EDIT FILE LOCATIONS ABOVE ===\n\n# === COLOR MAP ===\n\n## Text coloring and formatting is done by inserting ANSI escape codes.\n## If you have re-mapped your color codes, or use the todo.txt\n## output in another output system (like Conky), you may need to\n## over-ride by uncommenting and editing these defaults.\n## If you change any of these here, you also need to uncomment\n## the defaults in the COLORS section below. Otherwise, todo.txt\n## will still use the defaults!\n\n# export BLACK='\\\\033[0;30m'\n# export RED='\\\\033[0;31m'\n# export GREEN='\\\\033[0;32m'\n# export BROWN='\\\\033[0;33m'\n# export BLUE='\\\\033[0;34m'\n# export PURPLE='\\\\033[0;35m'\n# export CYAN='\\\\033[0;36m'\n# export LIGHT_GREY='\\\\033[0;37m'\n# export DARK_GREY='\\\\033[1;30m'\n# export LIGHT_RED='\\\\033[1;31m'\n# export LIGHT_GREEN='\\\\033[1;32m'\n# export YELLOW='\\\\033[1;33m'\n# export LIGHT_BLUE='\\\\033[1;34m'\n# export LIGHT_PURPLE='\\\\033[1;35m'\n# export LIGHT_CYAN='\\\\033[1;36m'\n# export WHITE='\\\\033[1;37m'\n# export DEFAULT='\\\\033[0m'\n\n# === COLORS ===\n\n## Uncomment and edit to override these defaults.\n## Reference the constants from the color map above,\n## or use $NONE to disable highlighting.\n#\n# Priorities can be any upper-case letter.\n# A,B,C are highlighted; you can add coloring for more.\n#\n# export PRI_A=$YELLOW        # color for A priority\n# export PRI_B=$GREEN         # color for B priority\n# export PRI_C=$LIGHT_BLUE    # color for C priority\n# export PRI_D=...            # define your own\n# export PRI_X=$WHITE         # color unless explicitly defined\n\n# There is highlighting for tasks that have been done,\n# but haven't been archived yet.\n#\n# export COLOR_DONE=$LIGHT_GREY\n\n# There is highlighting for projects and contexts.\n#\n# export COLOR_PROJECT=$RED\n# export COLOR_CONTEXT=$RED\n\n# === BEHAVIOR ===\n\n## customize list output\n#\n# TODOTXT_SORT_COMMAND will filter after line numbers are\n# inserted, but before colorization, and before hiding of\n# priority, context, and project.\n#\n# export TODOTXT_SORT_COMMAND='env LC_COLLATE=C sort -f -k2'\n\n# TODOTXT_FINAL_FILTER will filter list output after colorization,\n# priority hiding, context hiding, and project hiding. That is,\n# just before the list output is displayed.\n#\n# export TODOTXT_FINAL_FILTER='cat'\n","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":false,"range":[[84,0],[84,0]]},"newParams":{"tailed":true,"range":[[0,0],[84,0]]},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"}],"deserializer":"History"},"filePath":"/Users/bryce/Downloads/todo.txt_cli-2.10/todo.cfg","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"30426117c68f0766c91c0d771c395652806cbd15","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":7,"items":[{"id":12,"softTabs":true,"displayBuffer":{"id":13,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/Downloads/todo.txt_cli-2.10/todo.sh","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":16,"softTabs":true,"displayBuffer":{"id":17,"softWrap":false,"editorWidthInChars":null,"scrollTop":1024,"scrollLeft":2,"tokenizedBuffer":{"bufferPath":"/Users/bryce/Downloads/todo.txt_cli-2.10/todo_completion","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":28,"softTabs":true,"displayBuffer":{"id":29,"softWrap":false,"editorWidthInChars":null,"scrollTop":1350,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/Downloads/todo.txt_cli-2.10/todo.cfg","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/bryce/Downloads/todo.txt_cli-2.10/todo.cfg","focused":true,"deserializer":"Pane"},"activePaneId":7,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-shellscript"],"deserializer":"Workspace"},"packageStates":{"coffee-lint":{"height":0},"command-logger":{"eventLog":{"core:select-all":{"count":3,"name":"core:select-all","lastRun":1407434172827},"core:copy":{"count":4,"name":"core:copy","lastRun":1407434177120},"find-and-replace:show":{"count":2,"name":"find-and-replace:show","lastRun":1407434123810},"core:backspace":{"count":1,"name":"core:backspace","lastRun":1407434124751},"core:confirm":{"count":28,"name":"core:confirm","lastRun":1407434146094},"core:paste":{"count":1,"name":"core:paste","lastRun":1407434173690},"core:undo":{"count":1,"name":"core:undo","lastRun":1407434174713}}},"local-history":{"localHistoryViewState":""},"find-and-replace":{"viewState":{"findHistory":["todo"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}},"fuzzy-finder":{"/Users/bryce/Downloads/todo.txt_cli-2.10/todo.sh":1407433652894,"/Users/bryce/Downloads/todo.txt_cli-2.10/todo_completion":1407433803089,"/Users/bryce/Downloads/todo.txt_cli-2.10/todo.cfg":1407434169989},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":11705021},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/bryce/Downloads/todo.txt_cli-2.10/todo.cfg","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}