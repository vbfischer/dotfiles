{"mode":"editor","version":1,"windowDimensions":{"x":56,"y":22,"width":1201,"height":878},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/bryce/.dotfiles","buffers":[{"text":"#!/bin/sh\n\nBEACON_TRUNK=/Users/bryce/Code/BEACON\nBEACON_BRANCH=/Users/bryce/Code/BEACON_branch\n\norigFile=$BEACON_TRUNK/$1\nbranchFile=$BEACON_BRANCH/$1\n\nksdiff $origFile $branchFile\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[9,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":63,"goalBufferRange":null,"autoscroll":false},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/bdiff","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"0e73bc51952eb28c9407c8d0b66f6dba94770101","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n# Attempt to create a script to convert an .svg file to .png. Probably should make it more generic\n# i.e., convert any valid incoming file such as .gif, .jpg, etc.\n\nDIRECTORY=.\n\nfor i in $DIRECTORY/*.svg; do\n\tfile=\"${i#*.}\"\n\tfile=\"${file%%.*}\"\n\tnewFile=\".$file.png\"\n\n\techo \"convert -transparent black $i $newFile\"\n\tconvert -transparent white $i $newFile\n\tconvert -fill white -opaque black -fuzz 50% $newFile $newFile\ndone","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":67},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/csvg","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7dfc812ba519a22660cd4b939226d3c2f8b9de12","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Quick shortcut to an editor.\n#\n# This means that as I travel back and forth between editors, hey, I don't have\n# to re-learn any arcane commands. Neat.\n#\n# USAGE:\n#\n#   $ e\n#   # => opens the current directory in your editor\n#\n#   $ e .\n#   $ e /usr/local\n#   # => opens the specified directory in your editor\n\nif [ \"$1\" = \"\" ] ; then\n  exec $EDITOR .\nelse\n  exec $EDITOR \"$1\"\nfi\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":71},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/e","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"3f3cf4d4392177918f93efe04d32b9eb6d880544","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Stage all unstaged.\n\ngit add -A\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":75},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-all","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"92212bc957b2fb439918ed18df815d73d65d53ce","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Use the last commit message and amend your stuffs.\n\ngit commit --amend -C HEAD\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":79},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-amend","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"08f1f56c85392ac7aa3eff27623802a52b81b0aa","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# A very slightly quicker way to credit an author on the latest commit.\n#\n# $1 - The full name of the author.\n# $2 - The email address of the author.\n#\n# Examples\n#\n#   git credit \"Zach Holman\" zach@example.com\n#\n\ngit commit --amend --author \"$1 <$2>\" -C HEAD\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":83},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-credit","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"3bde1266e2b50f1604c0ec8f3fa4be9402b71fa9","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Delete all local branches that have been merged into HEAD. Stolen from\n# our favorite @tekkub:\n#\n#   https://plus.google.com/115587336092124934674/posts/dXsagsvLakJ\n\ngit branch -d `git branch --merged | grep -v '^*' | grep -v 'master' | tr -d '\\n'`\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":87},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-delete-local-merged","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"64fb77cf9f1ba4ed4581d033df6c65f7482fa4aa","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Nukes a branch locally and on the origin remote.\n#\n# $1 - Branch name.\n#\n# Examples\n#\n#   git nuke add-git-nuke\n\ngit branch -D $1\ngit push origin :$1\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":91},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-nuke","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"d6c4d61f335d4d0c380527056d46bb0177a8902c","deserializer":"TextBuffer"},{"text":"#!/usr/bin/env ruby\n\n## git-rank-contributors: a simple script to trace through the logs and\n## rank contributors by the total size of the diffs they're responsible for.\n## A change counts twice as much as a plain addition or deletion.\n##\n## Output may or may not be suitable for inclusion in a CREDITS file.\n## Probably not without some editing, because people often commit from more\n## than one address.\n##\n## git-rank-contributors Copyright 2008 William Morgan <wmorgan-git-wt-add@masanjin.net>. \n## This program is free software: you can redistribute it and/or modify\n## it under the terms of the GNU General Public License as published by\n## the Free Software Foundation, either version 3 of the License, or (at\n## your option) any later version.\n##\n## This program is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n## GNU General Public License for more details.\n##\n## You can find the GNU General Public License at:\n##   http://www.gnu.org/licenses/\n\nclass String\n  def obfuscate; gsub(/@/, \" at the \").gsub(/\\.(\\w+)(>|$)/, ' dot \\1s\\2') end\n  def htmlize; gsub(\"&\", \"&amp;\").gsub(\"<\", \"&lt;\").gsub(\">\", \"&gt;\") end\nend\n\nlines = {}\nverbose = ARGV.delete(\"-v\")\nobfuscate = ARGV.delete(\"-o\")\nhtmlize = ARGV.delete(\"-h\")\n\nauthor = nil\nstate = :pre_author\n`git log -M -C -C -p --no-color`.split(\"\\n\").each do |l|\n  case\n  when (state == :pre_author || state == :post_author) && l =~ /Author: (.*)$/\n    author = $1\n    state = :post_author\n    lines[author] ||= 0\n  when state == :post_author && l =~ /^\\+\\+\\+/\n    state = :in_diff\n  when state == :in_diff && l =~ /^[\\+\\-]/\n    lines[author] += 1\n  when state == :in_diff && l =~ /^commit /\n    state = :pre_author\n  end\nend\n\nlines.sort_by { |a, c| -c }.each do |a, c|\n  a = a.obfuscate if obfuscate\n  a = a.htmlize if htmlize\n  if verbose\n    puts \"#{a}: #{c} lines of diff\"\n  else\n    puts a\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":95},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-rank-contributors","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"87ad7c342877742dd13666f7529ac4dd4a0ae94b","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Sets up your branch to track a remote branch. Assumes you mean\n# `origin/$branch-name`.\n\nbranch=$(git rev-parse --abbrev-ref HEAD)\ngit branch $branch --set-upstream-to origin/$branch","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":99},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-track","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"4626b406e5a46949174abfeeb3dac91d96b9484a","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Undo your last commit, but don't throw away your changes\n\ngit reset --soft HEAD^\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":103},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-undo","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"77497f1927e8edee473f95530326a9f013165d29","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Show the diff of everything you haven't pushed yet.\n\nbranch=$(git rev-parse --abbrev-ref HEAD)\ngit diff origin/$branch..HEAD\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":107},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-unpushed","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"52c3e9ecf6df690ae0e2fccf326b2e33c947fcd3","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Show the diffstat of everything you haven't pushed yet.\n\nbranch=$(git rev-parse --abbrev-ref HEAD)\ncount=$(git rev-list --count HEAD origin/$branch...HEAD)\n\nif [ \"$count\" -eq \"1\" ]\nthen\n  s=''\nelse\n  s='s'\nfi\n\ngit diff --stat origin/$branch..HEAD\necho \" $count commit$s total\"\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":111},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-unpushed-stat","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"fff6b19e6708ba3fb15bf76c22023dec849d6029","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# Usage: git-up\n#        git-reup\n#\n# Like git-pull but show a short and sexy log of changes\n# immediately after merging (git-up) or rebasing (git-reup).\n#\n# Inspired by Kyle Neath's `git up' alias:\n# http://gist.github.com/249223\n#\n# Stolen from Ryan Tomayko\n# http://github.com/rtomayko/dotfiles/blob/rtomayko/bin/git-up\n\nset -e\n\nPULL_ARGS=\"$@\"\n\n# when invoked as git-reup, run as `git pull --rebase'\ntest \"$(basename $0)\" = \"git-reup\" &&\nPULL_ARGS=\"--rebase $PULL_ARGS\"\n\ngit pull $PULL_ARGS\n\n# show diffstat of all changes if we're pulling with --rebase. not\n# sure why git-pull only does this when merging.\ntest \"$(basename $0)\" = \"git-reup\" && {\n    echo \"Diff:\"\n    git --no-pager diff --color --stat HEAD@{1}.. |\n    sed 's/^/ /'\n}\n\n# show an abbreviated commit log of stuff that was just merged.\necho \"Log:\"\ngit log --color --pretty=oneline --abbrev-commit HEAD@{1}.. |\nsed 's/^/  /'\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":115},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-up","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"87d3ed27cebb3e0d3aee6d3ae7eb974586338018","deserializer":"TextBuffer"},{"text":"#!/usr/bin/env ruby\n\nHELP = <<EOS\ngit-wtf displays the state of your repository in a readable, easy-to-scan\nformat. It's useful for getting a summary of how a branch relates to a remote\nserver, and for wrangling many topic branches.\n\ngit-wtf can show you:\n- How a branch relates to the remote repo, if it's a tracking branch.\n- How a branch relates to integration branches, if it's a feature branch.\n- How a branch relates to the feature branches, if it's an integration\n  branch.\n\ngit-wtf is best used before a git push, or between a git fetch and a git\nmerge. Be sure to set color.ui to auto or yes for maximum viewing pleasure.\nEOS\n\nKEY = <<EOS\nKEY:\n() branch only exists locally\n{} branch only exists on a remote repo\n[] branch exists locally and remotely\n\nx merge occurs both locally and remotely\n~ merge occurs only locally\n  (space) branch isn't merged in\n\n(It's possible for merges to occur remotely and not locally, of course, but\nthat's a less common case and git-wtf currently doesn't display anything\nspecial for it.)\nEOS\n\nUSAGE = <<EOS\nUsage: git wtf [branch+] [options]\n\nIf [branch] is not specified, git-wtf will use the current branch. The possible\n[options] are:\n\n  -l, --long          include author info and date for each commit\n  -a, --all           show all branches across all remote repos, not just\n                      those from origin\n  -A, --all-commits   show all commits, not just the first 5\n  -s, --short         don't show commits\n  -k, --key           show key\n  -r, --relations     show relation to features / integration branches\n      --dump-config   print out current configuration and exit\n\ngit-wtf uses some heuristics to determine which branches are integration\nbranches, and which are feature branches. (Specifically, it assumes the\nintegration branches are named \"master\", \"next\" and \"edge\".) If it guesses\nincorrectly, you will have to create a .git-wtfrc file.\n\nTo start building a configuration file, run \"git-wtf --dump-config >\n.git-wtfrc\" and edit it. The config file is a YAML file that specifies the\nintegration branches, any branches to ignore, and the max number of commits to\ndisplay when --all-commits isn't used.  git-wtf will look for a .git-wtfrc file\nstarting in the current directory, and recursively up to the root.\n\nIMPORTANT NOTE: all local branches referenced in .git-wtfrc must be prefixed\nwith heads/, e.g. \"heads/master\". Remote branches must be of the form\nremotes/<remote>/<branch>.\nEOS\n\nCOPYRIGHT = <<EOS\ngit-wtf Copyright 2008--2009 William Morgan <wmorgan at the masanjin dot nets>.\nThis program is free software: you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the Free\nSoftware Foundation, either version 3 of the License, or (at your option)\nany later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\nmore details.\n\nYou can find the GNU General Public License at: http://www.gnu.org/licenses/\nEOS\n\nrequire 'yaml'\nCONFIG_FN = \".git-wtfrc\"\n\nclass Numeric; def pluralize s; \"#{to_s} #{s}\" + (self != 1 ? \"s\" : \"\") end end\n\nif ARGV.delete(\"--help\") || ARGV.delete(\"-h\")\n  puts USAGE\n  exit\nend\n\n## poor man's trollop\n$long = ARGV.delete(\"--long\") || ARGV.delete(\"-l\")\n$short = ARGV.delete(\"--short\") || ARGV.delete(\"-s\")\n$all = ARGV.delete(\"--all\") || ARGV.delete(\"-a\")\n$all_commits = ARGV.delete(\"--all-commits\") || ARGV.delete(\"-A\")\n$dump_config = ARGV.delete(\"--dump-config\")\n$key = ARGV.delete(\"--key\") || ARGV.delete(\"-k\")\n$show_relations = ARGV.delete(\"--relations\") || ARGV.delete(\"-r\")\nARGV.each { |a| abort \"Error: unknown argument #{a}.\" if a =~ /^--/ }\n\n## search up the path for a file\ndef find_file fn\n  while true\n    return fn if File.exist? fn\n    fn2 = File.join(\"..\", fn)\n    return nil if File.expand_path(fn2) == File.expand_path(fn)\n    fn = fn2\n  end\nend\n\nwant_color = `git config color.wtf`\nwant_color = `git config color.ui` if want_color.empty?\n$color = case want_color.chomp\n  when \"true\"; true\n  when \"auto\"; $stdout.tty?\nend\n\ndef red s; $color ? \"\\033[31m#{s}\\033[0m\" : s end\ndef green s; $color ? \"\\033[32m#{s}\\033[0m\" : s end\ndef yellow s; $color ? \"\\033[33m#{s}\\033[0m\" : s end\ndef cyan s; $color ? \"\\033[36m#{s}\\033[0m\" : s end\ndef grey s; $color ? \"\\033[1;30m#{s}\\033[0m\" : s end\ndef purple s; $color ? \"\\033[35m#{s}\\033[0m\" : s end\n\n## the set of commits in 'to' that aren't in 'from'.\n## if empty, 'to' has been merged into 'from'.\ndef commits_between from, to\n  if $long\n    `git log --pretty=format:\"- %s [#{yellow \"%h\"}] (#{purple \"%ae\"}; %ar)\" #{from}..#{to}`\n  else\n    `git log --pretty=format:\"- %s [#{yellow \"%h\"}]\" #{from}..#{to}`\n  end.split(/[\\r\\n]+/)\nend\n\ndef show_commits commits, prefix=\"    \"\n  if commits.empty?\n    puts \"#{prefix} none\"\n  else\n    max = $all_commits ? commits.size : $config[\"max_commits\"]\n    max -= 1 if max == commits.size - 1 # never show \"and 1 more\"\n    commits[0 ... max].each { |c| puts \"#{prefix}#{c}\" }\n    puts grey(\"#{prefix}... and #{commits.size - max} more (use -A to see all).\") if commits.size > max\n  end\nend\n\ndef ahead_behind_string ahead, behind\n  [ahead.empty? ? nil : \"#{ahead.size.pluralize 'commit'} ahead\",\n   behind.empty? ? nil : \"#{behind.size.pluralize 'commit'} behind\"].\n   compact.join(\"; \")\nend\n\ndef widget merged_in, remote_only=false, local_only=false, local_only_merge=false\n  left, right = case\n    when remote_only; %w({ })\n    when local_only; %w{( )}\n    else %w([ ])\n  end\n  middle = case\n    when merged_in && local_only_merge; green(\"~\")\n    when merged_in; green(\"x\")\n    else \" \"\n  end\n  print left, middle, right\nend\n\ndef show b\n  have_both = b[:local_branch] && b[:remote_branch]\n\n  pushc, pullc, oosync = if have_both\n    [x = commits_between(b[:remote_branch], b[:local_branch]),\n     y = commits_between(b[:local_branch], b[:remote_branch]),\n     !x.empty? && !y.empty?]\n  end\n\n  if b[:local_branch]\n    puts \"Local branch: \" + green(b[:local_branch].sub(/^heads\\//, \"\"))\n\n    if have_both\n      if pushc.empty?\n        puts \"#{widget true} in sync with remote\"\n      else\n        action = oosync ? \"push after rebase / merge\" : \"push\"\n        puts \"#{widget false} NOT in sync with remote (you should #{action})\"\n        show_commits pushc unless $short\n      end\n    end\n  end\n\n  if b[:remote_branch]\n    puts \"Remote branch: #{cyan b[:remote_branch]} (#{b[:remote_url]})\"\n\n    if have_both\n      if pullc.empty?\n        puts \"#{widget true} in sync with local\"\n      else\n        action = pushc.empty? ? \"merge\" : \"rebase / merge\"\n        puts \"#{widget false} NOT in sync with local (you should #{action})\"\n        show_commits pullc unless $short\n      end\n    end\n  end\n\n  puts \"\\n#{red \"WARNING\"}: local and remote branches have diverged. A merge will occur unless you rebase.\" if oosync\nend\n\ndef show_relations b, all_branches\n  ibs, fbs = all_branches.partition { |name, br| $config[\"integration-branches\"].include?(br[:local_branch]) || $config[\"integration-branches\"].include?(br[:remote_branch]) }\n  if $config[\"integration-branches\"].include? b[:local_branch]\n    puts \"\\nFeature branches:\" unless fbs.empty?\n    fbs.each do |name, br|\n      next if $config[\"ignore\"].member?(br[:local_branch]) || $config[\"ignore\"].member?(br[:remote_branch])\n      next if br[:ignore]\n      local_only = br[:remote_branch].nil?\n      remote_only = br[:local_branch].nil?\n      name = if local_only\n        purple br[:name]\n      elsif remote_only\n        cyan br[:name]\n      else\n        green br[:name]\n      end\n\n      ## for remote_only branches, we'll compute wrt the remote branch head. otherwise, we'll\n      ## use the local branch head.\n      head = remote_only ? br[:remote_branch] : br[:local_branch]\n\n      remote_ahead = b[:remote_branch] ? commits_between(b[:remote_branch], head) : []\n      local_ahead = b[:local_branch] ? commits_between(b[:local_branch], head) : []\n\n      if local_ahead.empty? && remote_ahead.empty?\n        puts \"#{widget true, remote_only, local_only} #{name} #{local_only ? \"(local-only) \" : \"\"}is merged in\"\n      elsif local_ahead.empty?\n        puts \"#{widget true, remote_only, local_only, true} #{name} merged in (only locally)\"\n      else\n        behind = commits_between head, (br[:local_branch] || br[:remote_branch])\n        ahead = remote_only ? remote_ahead : local_ahead\n        puts \"#{widget false, remote_only, local_only} #{name} #{local_only ? \"(local-only) \" : \"\"}is NOT merged in (#{ahead_behind_string ahead, behind})\"\n        show_commits ahead unless $short\n      end\n    end\n  else\n    puts \"\\nIntegration branches:\" unless ibs.empty? # unlikely\n    ibs.sort_by { |v, br| v }.each do |v, br|\n      next if $config[\"ignore\"].member?(br[:local_branch]) || $config[\"ignore\"].member?(br[:remote_branch])\n      next if br[:ignore]\n      local_only = br[:remote_branch].nil?\n      remote_only = br[:local_branch].nil?\n      name = remote_only ? cyan(br[:name]) : green(br[:name])\n\n      ahead = commits_between v, (b[:local_branch] || b[:remote_branch])\n      if ahead.empty?\n        puts \"#{widget true, local_only} merged into #{name}\"\n      else\n        #behind = commits_between b[:local_branch], v\n        puts \"#{widget false, local_only} NOT merged into #{name} (#{ahead.size.pluralize 'commit'} ahead)\"\n        show_commits ahead unless $short\n      end\n    end\n  end\nend\n\n#### EXECUTION STARTS HERE ####\n\n## find config file and load it\n$config = { \"integration-branches\" => %w(heads/master heads/next heads/edge), \"ignore\" => [], \"max_commits\" => 5 }.merge begin\n  fn = find_file CONFIG_FN\n  if fn && (h = YAML::load_file(fn)) # yaml turns empty files into false\n    h[\"integration-branches\"] ||= h[\"versions\"] # support old nomenclature\n    h\n  else\n    {}\n  end\nend\n\nif $dump_config\n  puts $config.to_yaml\n  exit\nend\n\n## first, index registered remotes\nremotes = `git config --get-regexp ^remote\\.\\*\\.url`.split(/[\\r\\n]+/).inject({}) do |hash, l|\n  l =~ /^remote\\.(.+?)\\.url (.+)$/ or next hash\n  hash[$1] ||= $2\n  hash\nend\n\n## next, index followed branches\nbranches = `git config --get-regexp ^branch\\.`.split(/[\\r\\n]+/).inject({}) do |hash, l|\n  case l\n  when /branch\\.(.*?)\\.remote (.+)/\n    name, remote = $1, $2\n\n    hash[name] ||= {}\n    hash[name].merge! :remote => remote, :remote_url => remotes[remote]\n  when /branch\\.(.*?)\\.merge ((refs\\/)?heads\\/)?(.+)/\n    name, remote_branch = $1, $4\n    hash[name] ||= {}\n    hash[name].merge! :remote_mergepoint => remote_branch\n  end\n  hash\nend\n\n## finally, index all branches\nremote_branches = {}\n`git show-ref`.split(/[\\r\\n]+/).each do |l|\n  sha1, ref = l.chomp.split \" refs/\"\n\n  if ref =~ /^heads\\/(.+)$/ # local branch\n    name = $1\n    next if name == \"HEAD\"\n    branches[name] ||= {}\n    branches[name].merge! :name => name, :local_branch => ref\n  elsif ref =~ /^remotes\\/(.+?)\\/(.+)$/ # remote branch\n    remote, name = $1, $2\n    remote_branches[\"#{remote}/#{name}\"] = true\n    next if name == \"HEAD\"\n    ignore = !($all || remote == \"origin\")\n\n    branch = name\n    if branches[name] && branches[name][:remote] == remote\n      # nothing\n    else\n      name = \"#{remote}/#{branch}\"\n    end\n\n    branches[name] ||= {}\n    branches[name].merge! :name => name, :remote => remote, :remote_branch => \"#{remote}/#{branch}\", :remote_url => remotes[remote], :ignore => ignore\n  end\nend\n\n## assemble remotes\nbranches.each do |k, b|\n  next unless b[:remote] && b[:remote_mergepoint]\n  b[:remote_branch] = if b[:remote] == \".\"\n    b[:remote_mergepoint]\n  else\n    t = \"#{b[:remote]}/#{b[:remote_mergepoint]}\"\n    remote_branches[t] && t # only if it's still alive\n  end\nend\n\nshow_dirty = ARGV.empty?\ntargets = if ARGV.empty?\n  [`git symbolic-ref HEAD`.chomp.sub(/^refs\\/heads\\//, \"\")]\nelse\n  ARGV.map { |x| x.sub(/^heads\\//, \"\") }\nend.map { |t| branches[t] or abort \"Error: can't find branch #{t.inspect}.\" }\n\ntargets.each do |t|\n  show t\n  show_relations t, branches if $show_relations || t[:remote_branch].nil?\nend\n\nmodified = show_dirty && `git ls-files -m` != \"\"\nuncommitted = show_dirty &&  `git diff-index --cached HEAD` != \"\"\n\nif $key\n  puts\n  puts KEY\nend\n\nputs if modified || uncommitted\nputs \"#{red \"NOTE\"}: working directory contains modified files.\" if modified\nputs \"#{red \"NOTE\"}: staging area contains staged but uncommitted files.\" if uncommitted\n\n# the end!","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":119},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/git-wtf","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a63a03e7a34814cd6fd9d40875247cd706b2ee37","deserializer":"TextBuffer"},{"text":"#!/usr/bin/env ruby\n# Usage: gitio URL [CODE]\n#\n# Turns a github.com URL\n#  into a git.io URL\n#\n# Created by @defunkt:\n#  https://gist.github.com/1209316 \n#\n# Copies the git.io URL to your clipboard.\n\nurl  = ARGV[0]\ncode = ARGV[1]\n\nif url !~ /^(https?:\\/\\/)?(gist\\.)?github.com/\n  abort \"* github.com URLs only\"\nend\n\nif url !~ /^http/\n  url = \"https://#{url}\"\nend\n\nif code\n  code = \"-F code=#{code}\"\nend\n\noutput = `curl -i http://git.io -F 'url=#{url}' #{code} 2> /dev/null`\nif output =~ /Location: (.+)\\n?/\n  puts $1\n  `echo #$1 | pbcopy`\nelse\n  puts output\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":123},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/gitio","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a1d9580f71410f852f044a8e11d0fc778e7bd1ef","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n#\n# https://github.com/rtomayko/dotfiles/blob/rtomayko/bin/headers\n\ncurl -sv \"$@\" 2>&1 >/dev/null |\n  grep -v \"^\\*\" |\n  grep -v \"^}\" |\n  cut -c3-","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":127},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/headers","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"9c3dc5df8f617c7b7f0fe3bd8e8a63d42143868f","deserializer":"TextBuffer"},{"text":"#!/bin/sh\n\nln -s ~/Documents/WoWAddons/$1 /Applications/World\\ of\\ Warcraft/Interface/AddOns/$1\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":131},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/linkaddon","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"99f1205539717ca24da45a159927d6d819061950","deserializer":"TextBuffer"},{"text":"BEACON_ENV=\"wmecrmd02.idexxi.com\"\n\ncase \"$1\" in\n    Dev1)\n        BEACON_ENV=$DEV1_ENV\n        MNT_FOLDER=$DEV1_MOUNT\n        ;;\n    Dev2)\n        BEACON_ENV=$DEV2_ENV\n        MNT_FOLDER=$DEV2_MOUNT\n        ;;\n    QA1)\n        BEACON_ENV=$QA1_ENV\n        MNT_FOLDER=$QA1_MOUNT\n        ;;\n    QA2)\n        BEACON_ENV=$QA2_ENV\n        MNT_FOLDER=$QA2_MOUNT\n        ;;\n    PR1)\n        BEACON_ENV=$PR1_ENV\n        MNT_FOLDER=$PR1_MOUNT\n        ;;\n    PR2)\n        BEACON_ENV=$PR2_ENV\n        MNT_FOLDER=$PR2_MOUNT\n        ;;\n    *)\n        echo \"Usage: $0 {Dev1|Dev2|QA1|QA2|PR1|PR2}\"\n        exit 1\n        ;;\nesac\n\ncase \"$2\" in\n    -u)\n        umount -f $MNT_FOLDER\n        ;;\n    *)\n        sshfs $IDEXX_USER_NAME@$BEACON_ENV:/fmw/log $MNT_FOLDER\n        ;;\nesac\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":135},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/mssh","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"85721c420b5538b9fdb70b5f6f7de05ab8072360","deserializer":"TextBuffer"},{"text":"#!/bin/bash\nDIFF=\"/usr/bin/opendiff\"\n\nLEFT=${6}\nRIGHT=${7}\n\n# echo ${@}\n$DIFF $LEFT $RIGHT ","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":139},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/mydifftool.sh","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"920c8db0c3d90384c09f234298126787c6db02b7","deserializer":"TextBuffer"},{"text":"#!/usr/bin/env node\n\nvar exec = require('child_process').exec;\n\nif(process.argv.length <= 2) {\n  console.error('Invalid command');\n}\n\nvar command = process.argv[2];\nvar me = this;\n\nswitch(command) {\n  case '1':\n    exec(\"svn log -l 100 | grep 'bfischer' | awk '/ / { print $1 }'\", function(error, stdout, stdin) {\n      if(!stdout) {\n        exit(1);\n      }\n\n      var out = stdout.split('\\n');\n      if(out.length == 0) {\n        exit(1);\n      }\n\n      var currentRevision = out[0];\n\n      me.doCmd('svn log --verbose -r ' + currentRevision);\n    });\n    console.log('doing 1');\n    break;\n  default:\n    console.log('doing default');\n}\n\nthis.doCmd = function(cmd) {\n  exec(cmd, function(error, stdout, stdin) {\n    console.log(\"E: \" + error);\n    console.log(stdout);\n  });\n}\n","markers":{"markers":{"1":{"id":1,"range":[[14,19],[14,19]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":143,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/bryce/.dotfiles/bin/nsvn","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"0f4cbb94235d1e3478b64df56352586a09fc1835","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":7,"items":[{"id":63,"softTabs":true,"displayBuffer":{"id":64,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/bdiff","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":67,"softTabs":false,"displayBuffer":{"id":68,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/csvg","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":71,"softTabs":true,"displayBuffer":{"id":72,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/e","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":75,"softTabs":true,"displayBuffer":{"id":76,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-all","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":79,"softTabs":true,"displayBuffer":{"id":80,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-amend","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":83,"softTabs":true,"displayBuffer":{"id":84,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-credit","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":87,"softTabs":true,"displayBuffer":{"id":88,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-delete-local-merged","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":91,"softTabs":true,"displayBuffer":{"id":92,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-nuke","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":95,"softTabs":true,"displayBuffer":{"id":96,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-rank-contributors","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":99,"softTabs":true,"displayBuffer":{"id":100,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-track","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":103,"softTabs":true,"displayBuffer":{"id":104,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-undo","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":107,"softTabs":true,"displayBuffer":{"id":108,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-unpushed","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":111,"softTabs":true,"displayBuffer":{"id":112,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-unpushed-stat","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":115,"softTabs":true,"displayBuffer":{"id":116,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-up","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":119,"softTabs":true,"displayBuffer":{"id":120,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/git-wtf","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":123,"softTabs":true,"displayBuffer":{"id":124,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/gitio","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":127,"softTabs":true,"displayBuffer":{"id":128,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/headers","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":131,"softTabs":true,"displayBuffer":{"id":132,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/linkaddon","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":135,"softTabs":true,"displayBuffer":{"id":136,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/mssh","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":139,"softTabs":true,"displayBuffer":{"id":140,"softWrap":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/mydifftool.sh","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":143,"softTabs":true,"displayBuffer":{"id":144,"softWrap":false,"editorWidthInChars":null,"scrollTop":161,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/bryce/.dotfiles/bin/nsvn","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/bryce/.dotfiles/bin/bdiff","focused":false,"deserializer":"Pane"},"activePaneId":7,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-shellscript","language-ruby","language-javascript"],"deserializer":"Workspace"},"packageStates":{"coffee-lint":{"height":0},"command-logger":{"eventLog":{"core:select-down":{"count":3,"name":"core:select-down","lastRun":1407247332065},"core:copy":{"count":3,"name":"core:copy","lastRun":1407250094797},"core:select-all":{"count":1,"name":"core:select-all","lastRun":1407250093517}}},"local-history":{"localHistoryViewState":""},"fuzzy-finder":{"/Users/bryce/.dotfiles/bin/bdiff":1407250089446,"/Users/bryce/.dotfiles/bin/csvg":1407245438838,"/Users/bryce/.dotfiles/bin/e":1407245446223,"/Users/bryce/.dotfiles/bin/git-all":1407245447182,"/Users/bryce/.dotfiles/bin/git-amend":1407245448470,"/Users/bryce/.dotfiles/bin/git-credit":1407245449602,"/Users/bryce/.dotfiles/bin/git-delete-local-merged":1407245454881,"/Users/bryce/.dotfiles/bin/git-nuke":1407245455980,"/Users/bryce/.dotfiles/bin/git-rank-contributors":1407245457117,"/Users/bryce/.dotfiles/bin/git-track":1407245462069,"/Users/bryce/.dotfiles/bin/git-undo":1407245472102,"/Users/bryce/.dotfiles/bin/git-unpushed":1407245473454,"/Users/bryce/.dotfiles/bin/git-unpushed-stat":1407245475807,"/Users/bryce/.dotfiles/bin/git-up":1407245476711,"/Users/bryce/.dotfiles/bin/git-wtf":1407245477953,"/Users/bryce/.dotfiles/bin/gitio":1407245479617,"/Users/bryce/.dotfiles/bin/headers":1407245480966,"/Users/bryce/.dotfiles/bin/linkaddon":1407245483419,"/Users/bryce/.dotfiles/bin/mssh":1407245485707,"/Users/bryce/.dotfiles/bin/mydifftool.sh":1407245487309,"/Users/bryce/.dotfiles/bin/nsvn":1407245490700},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":18419798},"tree-view":{"directoryExpansionStates":{"bin":{}},"selectedPath":"/Users/bryce/.dotfiles/bin/bdiff","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":42,"width":200}}}